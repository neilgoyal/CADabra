{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `rail8020` function in the KCL content, and how does it utilize parameters like `originStart`, `railHeight`, and `railLength` to create an adjustable 80/20 extruded aluminum linear rail?"}, {"role": "assistant", "content": "The `rail8020` function in KCL (Kinetic Command Language) is designed to create a customizable 80/20 extruded aluminum linear rail, which is commonly used in various engineering and construction applications. This function allows users to specify parameters that define the rail's dimensions and position, making it versatile for different projects.\n\n### Purpose of the `rail8020` Function\n\nThe primary purpose of the `rail8020` function is to generate a 3D model of an 80/20 aluminum rail with a T-slot profile. This profile is particularly useful for modular construction, allowing for easy assembly and reconfiguration of structures. The function takes three parameters: `originStart`, `railHeight`, and `railLength`, which control the position, height, and length of the rail, respectively.\n\n### Parameters Explained\n\n1. **`originStart`**: This parameter is an array that defines the starting coordinates of the rail in the 3D space. It allows the user to position the rail at any desired location. For example, `originStart = [0, 0]` places the rail at the origin of the coordinate system.\n\n2. **`railHeight`**: This parameter determines the height of the rail's profile. The height is used throughout the function to scale various dimensions of the rail, ensuring that the profile maintains its proportions regardless of the specified height. For instance, if `railHeight` is set to `1.5`, all dimensions that depend on height will be scaled accordingly.\n\n3. **`railLength`**: This parameter specifies the length of the rail. It is used in the extrusion process to create the 3D shape of the rail from the 2D sketch. For example, if `railLength` is set to `48`, the resulting rail will be extruded to a length of 48 units.\n\n### Function Workflow\n\nThe function begins by sketching the profile of the rail on the `-XZ` plane. It uses a series of geometric commands to create arcs, lines, and angled lines that define the T-slot profile. The profile is constructed in multiple segments, ensuring that all edges and corners are accurately represented.\n\n- **Sketching the Profile**: The function employs a sequence of commands to create the four sides of the rail's profile. Each side is defined using arcs and lines, with dimensions scaled by the `railHeight` parameter. This ensures that the profile is adjustable and can be modified based on user input.\n\n- **Center Hole**: A central hole is added to the profile, which is also positioned based on the `originStart` and scaled according to the `railHeight`. This hole is essential for the functionality of the T-slot, allowing for the attachment of various components.\n\n- **Extrusion**: After the 2D profile is defined, the function extrudes the sketch to the specified `railLength`, converting the 2D shape into a 3D object.\n\n- **Filleting Edges**: The function applies fillets to certain edges to smooth out sharp corners, enhancing the rail's aesthetics and functionality. Two different fillet radii are used to create a more refined appearance.\n\n### Example Usage\n\nThe function can be called with specific parameters to generate a rail. For instance, `rail8020([0, 0], 1.5, 48)` creates a rail starting at the origin, with a height of 1.5 units and a length of 48 units. This flexibility allows users to create rails tailored to their specific needs, whether for prototyping, manufacturing, or assembly.\n\n### Conclusion\n\nIn summary, the `rail8020` function in KCL is a powerful tool for generating customizable 80/20 aluminum linear rails. By utilizing parameters like `originStart`, `railHeight`, and `railLength`, users can create adjustable and versatile rail profiles suitable for a wide range of applications. The function's detailed sketching, extrusion, and filleting processes ensure that the resulting model is both functional and visually appealing."}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `startSketchOn` function in the context of creating a parametric bearing pillow block in KCL, and how is it utilized in the provided code?"}, {"role": "assistant", "content": "The `startSketchOn` function in KCL (Kinetic CAD Language) is a crucial component for creating 2D sketches that serve as the foundation for 3D modeling. In the context of creating a parametric bearing pillow block, `startSketchOn` is used to initiate a new sketch on a specified plane, allowing the designer to define the geometry of the pillow block and its features, such as holes for bearings and counterbores.\n\n### Purpose of `startSketchOn`\n\n1. **Initiation of Sketching**: The primary purpose of `startSketchOn` is to begin a new sketch on a defined plane. In the provided code, the first call to `startSketchOn('XY')` indicates that the sketch will be created on the XY plane, which is a common choice for base features in 3D modeling.\n\n2. **Defining Geometry**: After initiating the sketch, various geometric elements are defined using functions like `startProfileAt`, `lineTo`, and `close`. These functions allow the user to outline the shape of the pillow block, including its dimensions and the locations of holes.\n\n3. **Creating Holes**: The function is also used to create holes in the sketch. The `hole` function is called multiple times to define the locations and sizes of holes for mounting and bearing placement. This is essential for the functionality of the pillow block, as it needs to accommodate bearings and possibly other components.\n\n4. **Extrusion**: After defining the 2D sketch, the `extrude` function is called to convert the 2D profile into a 3D object. The height of the extrusion is determined by the parameters defined earlier in the code.\n\n### Utilization in the Provided Code\n\nIn the provided code, `startSketchOn` is utilized in two distinct parts:\n\n1. **First Sketch**:\n   ```kcl\n   block = startSketchOn('XY')\n   ```\n   - This line starts the first sketch on the XY plane. The subsequent lines define the outline of the pillow block and create holes for the bearings and mounting. The sketch is then extruded to create the main body of the pillow block, minus the counterbore depth.\n\n2. **Second Sketch**:\n   ```kcl\n   secondHalf = startSketchOn({\n       plane: {\n         origin: { x: 0, y: 0, z: height - cbDepth },\n         xAxis: { x: 1, y: 0, z: 0 },\n         yAxis: { x: 0, y: 1, z: 0 },\n         zAxis: { x: 0, y: 0, z: 1 }\n       }\n     })\n   ```\n   - The second call to `startSketchOn` is more complex, as it defines a new sketch on a plane that is offset in the Z direction (at `height - cbDepth`). This is necessary to create the counterbore features on the top of the pillow block. The sketching process is similar to the first, where the outline is defined, and additional holes are created for the counterbores. Finally, this sketch is extruded to complete the height of the pillow block.\n\n### Conclusion\n\nIn summary, the `startSketchOn` function is essential for initiating sketches in KCL, allowing for the creation of complex geometries required for components like a parametric bearing pillow block. It facilitates the definition of 2D profiles that can be extruded into 3D shapes, enabling the designer to incorporate necessary features such as holes and counterbores effectively. The careful use of this function in the provided code demonstrates its importance in the design process within KCL."}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `patternCircular3d` function in the context of creating a ball bearing, and how is it utilized in the provided KCL code?"}, {"role": "assistant", "content": "The `patternCircular3d` function in KCL (Kinematic Construction Language) is used to create multiple instances of a geometric shape arranged in a circular pattern around a specified axis. In the context of creating a ball bearing, this function is particularly useful for replicating the spherical balls that are integral to the design of the bearing.\n\n### Purpose of `patternCircular3d`\n\nIn the provided KCL code, the `patternCircular3d` function serves the following purposes:\n\n1. **Replicating Balls**: The primary function of the ball bearing is to reduce friction and support loads, which is achieved by the arrangement of multiple balls. The `patternCircular3d` function allows for the creation of these balls in a circular formation around the central axis of the bearing.\n\n2. **Defining Instances**: The function takes parameters such as `instances`, which specifies how many copies of the original shape (in this case, the ball) should be created. This is crucial for ensuring that the correct number of balls (defined by `nBalls`) is included in the design.\n\n3. **Controlling Orientation**: The `rotateDuplicates` parameter allows for the orientation of the duplicated instances to be controlled. Setting this to `true` ensures that the balls are evenly spaced and oriented correctly around the axis, maintaining the symmetry required for the bearing's functionality.\n\n4. **Circular Arrangement**: The parameters `arcDegrees`, `axis`, and `center` define the circular path along which the instances are arranged. This is essential for creating a uniform distribution of the balls around the bearing's inner wall.\n\n### Utilization in the KCL Code\n\nIn the provided KCL code, the `patternCircular3d` function is utilized in two main instances:\n\n1. **Creating the Balls**:\n   ```kcl\n   balls = revolve({\n       axis: \"X\",\n   }, ballsSketch)\n   |> patternCircular3d({\n       arcDegrees: 360,\n       axis: [0, 0, 1],\n       center: [0, 0, 0],\n       instances: nBalls,\n       rotateDuplicates: true\n   }, %)\n   ```\n   - Here, the `ballsSketch` is revolved around the X-axis to create a single sphere. The `patternCircular3d` function then takes this sphere and arranges `nBalls` (10 in this case) of them in a circular pattern around the Z-axis, centered at the origin. This effectively creates the complete set of balls that will be used in the ball bearing.\n\n2. **Creating the Chain**:\n   ```kcl\n   chainHead = revolve({\n       axis: \"X\",\n   }, chainSketch)\n   |> patternCircular3d({\n       arcDegrees: 360,\n       axis: [0, 0, 1],\n       center: [0, 0, 0],\n       instances: nBalls,\n       rotateDuplicates: true,\n   }, %)\n   ```\n   - Similarly, the `chainSketch` is revolved to create a chain component, which is also duplicated around the Z-axis using `patternCircular3d`. This ensures that the chain wraps around the balls in a consistent manner, maintaining the structural integrity and functionality of the ball bearing.\n\n### Conclusion\n\nThe `patternCircular3d` function is a powerful tool in KCL for creating complex geometries like ball bearings. By allowing for the easy replication of shapes in a circular arrangement, it simplifies the design process and ensures that components are accurately positioned to fulfill their mechanical roles. In the context of the provided code, it is essential for both the creation of the balls and the chain that interacts with them, highlighting its importance in the overall design of the ball bearing."}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `extrude` function in the KCL content provided, and how is it utilized in the creation of the shelf bracket?"}, {"role": "assistant", "content": "The `extrude` function in the KCL (Kinematic Construction Language) content provided is a critical operation used to create three-dimensional shapes from two-dimensional sketches. In the context of the shelf bracket design, the `extrude` function is employed to transform the 2D profiles of the bracket legs into 3D solid components, which are essential for the structural integrity and functionality of the bracket.\n\n### Purpose of the `extrude` Function\n\n1. **3D Shape Creation**: The primary purpose of the `extrude` function is to take a 2D sketch (a profile) and extend it along a specified direction to create a 3D solid. This is fundamental in CAD (Computer-Aided Design) modeling, where most components start as 2D sketches before being converted into 3D objects.\n\n2. **Material Thickness**: In the case of the shelf bracket, the `extrude` function is used to apply the calculated thickness of the bracket, which is derived from the mechanical requirements (force, safety factor, material properties). This ensures that the bracket can withstand the specified load while maintaining structural integrity.\n\n3. **Filleting Edges**: After the extrusion, the `extrude` function is often followed by additional operations, such as filleting edges. This is evident in the provided code, where the `fillet` function is applied to the edges of the extruded shapes to create rounded corners, which can help reduce stress concentrations and improve the aesthetic appearance of the bracket.\n\n### Utilization in the Creation of the Shelf Bracket\n\n1. **First Leg Extrusion**:\n   - The first leg of the bracket is sketched using the `startSketchOn` function, which defines the 2D profile of the leg. The sketch includes lines and holes for mounting.\n   - The `extrude` function is then called with the calculated `thickness` to create the 3D solid for the first leg of the bracket. This leg is designed to support the shelf and is critical for load-bearing.\n\n   ```kcl\n   bracketLeg1Extrude = extrude(thickness, bracketLeg1Sketch)\n     |> fillet({\n       radius: extFilletRadius,\n       tags: [\n         getNextAdjacentEdge(fillet1),\n         getNextAdjacentEdge(fillet2)\n       ],\n     }, %)\n   ```\n\n2. **Second Leg Extrusion**:\n   - A similar process is followed for the second leg of the bracket. A custom plane is defined to orient the sketch correctly for the second leg, which is mounted against the wall.\n   - The `extrude` function is again utilized, but this time with a negative thickness to create the leg that extends in the opposite direction. This is crucial for ensuring that the bracket can be mounted securely to the wall.\n\n   ```kcl\n   bracketLeg2Extrude = extrude(-thickness, bracketLeg2Sketch)\n     |> fillet({\n       radius: extFilletRadius,\n       tags: [\n         getNextAdjacentEdge(fillet3),\n         getNextAdjacentEdge(fillet4)\n       ],\n     }, %)\n   ```\n\n### Conclusion\n\nIn summary, the `extrude` function in the KCL content is essential for converting the 2D sketches of the shelf bracket legs into 3D solids, allowing for the creation of a functional and structurally sound bracket. It plays a vital role in the design process by enabling the application of material thickness based on engineering calculations and facilitating the addition of features like fillets to enhance the bracket's performance and appearance."}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `startSketchOn` function in the context of designing a brake caliper, and how does it contribute to the overall modeling process?"}, {"role": "assistant", "content": "The `startSketchOn` function plays a crucial role in the modeling process of a brake caliper within the KCL (Kinematic Construction Language) framework. This function is essential for initiating a 2D sketch on a defined plane, which serves as the foundation for creating the 3D geometry of the brake caliper.\n\n### Purpose of `startSketchOn`\n\n1. **Defining the Sketch Plane**: The `startSketchOn` function takes a defined plane (in this case, `brakeCaliperPlane`) as an argument. This plane is established with specific coordinates and axes, ensuring that the sketch aligns correctly with the rotor model. The plane's origin and orientation are critical for accurately positioning the brake caliper in relation to other components in the assembly.\n\n2. **Initiating the Sketching Process**: By invoking `startSketchOn`, the user transitions into a sketching mode where they can define the 2D profile of the brake caliper. This is the first step in creating the geometric representation of the caliper, which will later be extruded or revolved into a 3D object.\n\n3. **Facilitating Geometric Construction**: Once the sketch is initiated, the subsequent commands (like `startProfileAt`, `line`, and `tangentialArc`) can be used to construct the intricate shapes and features of the brake caliper. The sketching commands build upon the initial plane established by `startSketchOn`, allowing for precise control over the dimensions and curvature of the caliper's profile.\n\n### Contribution to the Overall Modeling Process\n\n- **Precision and Control**: The ability to start a sketch on a specific plane allows for precise control over the dimensions and relationships between different parts of the brake caliper. This is particularly important in engineering applications where tolerances and fit are critical.\n\n- **Complex Geometry Creation**: The brake caliper design involves complex shapes, including arcs and lines that must be accurately defined. The `startSketchOn` function sets the stage for these operations, enabling the designer to create a detailed cross-section that reflects the functional requirements of the caliper.\n\n- **Integration with 3D Modeling**: After the 2D sketch is completed, it can be transformed into a 3D model using operations like `revolve`. The initial sketch created with `startSketchOn` serves as the basis for these transformations, ensuring that the final 3D geometry accurately represents the intended design.\n\n- **Iterative Design Process**: The sketching process is often iterative, allowing designers to refine the shape of the brake caliper based on performance criteria or aesthetic considerations. The `startSketchOn` function enables quick adjustments to the 2D profile, which can then be easily updated in the 3D model.\n\nIn summary, the `startSketchOn` function is a foundational element in the KCL modeling process for the brake caliper. It establishes the sketching environment on a defined plane, allowing for the precise creation of the caliper's geometry, which is essential for its functionality and integration within the braking system."}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `spoke` function in the KCL code for the car wheel, and how does it contribute to the overall design of the wheel?"}, {"role": "assistant", "content": "The `spoke` function in the KCL (Kinetic Code Language) code for the car wheel serves a critical role in defining the geometry and structural integrity of the wheel's spokes. Here's a detailed breakdown of its purpose and contribution to the overall design of the wheel:\n\n### Purpose of the `spoke` Function\n\n1. **Geometry Definition**: The `spoke` function is responsible for creating the cross-sectional profile of the spokes that connect the wheel's hub to its outer rim. This profile is defined using a series of geometric operations, including bezier curves and lines, which allow for a smooth and aerodynamic shape.\n\n2. **Customization of Parameters**: The function takes three parameters: `spokeGap`, `spokeAngle`, and `spokeThickness`. These parameters allow for customization of the spoke design:\n   - **`spokeGap`**: This parameter controls the vertical separation of the spoke base planes, influencing how the spokes are positioned relative to the wheel's center.\n   - **`spokeAngle`**: This parameter affects the angle at which the spokes are oriented, which can impact both aesthetics and structural performance.\n   - **`spokeThickness`**: This parameter determines the thickness of the spokes, which is crucial for ensuring that they can withstand the forces exerted during driving.\n\n3. **Pattern Creation**: The function utilizes a circular patterning technique (`patternCircular3d`) to replicate the spoke profile around the wheel. This is essential for achieving the desired number of spokes (defined by `spokeCount`) and ensuring they are evenly distributed around the wheel.\n\n4. **Structural Integrity**: By defining the spoke geometry and creating a robust pattern, the function contributes to the overall strength and stability of the wheel. The spokes are critical for transferring loads from the wheel to the vehicle chassis, especially during high-performance driving conditions.\n\n### Contribution to Overall Design\n\n1. **Aesthetic Appeal**: The design of the spokes significantly influences the visual appearance of the wheel. The use of curves and varying thicknesses can create a sporty and aggressive look, which is often desired in sports car designs.\n\n2. **Weight Reduction**: The spoke design can also be optimized for weight reduction while maintaining strength. By carefully designing the spoke profile and thickness, the overall weight of the wheel can be minimized, which is beneficial for performance.\n\n3. **Aerodynamics**: The shape and orientation of the spokes can affect the aerodynamics of the wheel. A well-designed spoke can help reduce drag and improve the vehicle's overall efficiency, especially at high speeds.\n\n4. **Manufacturability**: The function encapsulates the spoke design in a way that can be easily modified and replicated, making it suitable for manufacturing processes. This modular approach allows for quick adjustments to the design without needing to rewrite the entire wheel model.\n\n### Conclusion\n\nIn summary, the `spoke` function is a vital component of the KCL code for the car wheel, as it defines the spoke geometry, allows for customization, and contributes to the wheel's structural integrity, aesthetics, and performance. By leveraging this function, designers can create a wheel that not only looks good but also performs well under the demands of sports car driving."}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `lugPattern` function in the car-wheel-assembly KCL content, and how is it utilized in the creation of the rotor and lug nut components?"}, {"role": "assistant", "content": "The `lugPattern` function in the KCL (Kinematic Control Language) content for the car-wheel-assembly serves a crucial role in defining the layout of the lug holes on the rotor and lug nut components. This function is designed to create a circular pattern of holes that correspond to the lug nuts, which are essential for securing the wheel to the vehicle.\n\n### Purpose of the `lugPattern` Function\n\n1. **Creating Lug Holes**: The primary purpose of the `lugPattern` function is to generate a circular array of holes that will accommodate the lug nuts. This is essential for the assembly of the wheel, as the lug nuts must align perfectly with the holes in the rotor to ensure a secure fit.\n\n2. **Parameterization**: The function takes a `plane` parameter, which allows it to be used in different contexts or orientations within the 3D space. This flexibility is important for ensuring that the lug holes can be accurately placed on various components of the wheel assembly.\n\n3. **Reusability**: By encapsulating the logic for creating the lug hole pattern within a function, it promotes code reusability. The same function can be called multiple times for different components (like the rotor and the secondary rotor) without duplicating code.\n\n### Utilization in Rotor and Lug Nut Components\n\n1. **In the Rotor**:\n   - The `lugPattern` function is called within the context of creating the rotor. Specifically, it is used in the `rotorSketch` where the function is invoked to create the holes for the lug nuts:\n     ```kcl\n     rotorSketch = startSketchOn(rotorPlane)\n       |> circle({center: [0, 0], radius: rotorDiameter/2 * 25.4}, %)\n       |> hole(lugPattern(%), %)\n     ```\n   - Here, the `hole` function is used to create the actual holes in the rotor based on the pattern generated by `lugPattern`. This ensures that the rotor has the correct number of holes (defined by `lugCount`) and that they are evenly spaced in a circular arrangement.\n\n2. **In the Secondary Rotor**:\n   - The `lugPattern` function is also utilized in the creation of a secondary rotor, ensuring that it has the same lug hole configuration as the primary rotor:\n     ```kcl\n     secondaryRotorSketch = startSketchOn(rotorSecondaryPlatePlane)\n       |> circle({center: [0, 0], radius: rotorDiameter/2 * 25.4}, %)\n       |> hole(lugPattern(%), %)\n     ```\n   - This consistency is vital for ensuring that both rotors can be mounted using the same lug nuts, maintaining compatibility and structural integrity.\n\n3. **In the Lug Nut Creation**:\n   - While the `lugPattern` function is primarily focused on creating holes for the lug nuts, the actual lug nuts themselves are created using a separate function (`lug`). However, the circular pattern of lug nuts is defined using a similar approach, ensuring that they are positioned correctly around the rotor.\n\n### Conclusion\n\nThe `lugPattern` function is a key component in the KCL code for the car-wheel-assembly, facilitating the creation of a precise and repeatable pattern of lug holes on the rotor and secondary rotor. Its design promotes reusability and flexibility, allowing for consistent application across different components of the wheel assembly. This ensures that the assembly process is efficient and that the components fit together securely, which is critical for the safety and performance of the vehicle."}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `ngon` function in the KCL code for constructing a hollow dodecahedron, and how is it utilized to create the individual pentagonal faces?"}, {"role": "assistant", "content": "The `ngon` function in the KCL (KUKA Control Language) code is designed to create a regular polygon, specifically a pentagon in this context, which is essential for constructing the individual faces of a hollow dodecahedron. The function takes three parameters: `plane`, `numSides`, and `radius`. Here's a detailed breakdown of its purpose and usage:\n\n### Purpose of the `ngon` Function\n\n1. **Polygon Creation**: The primary purpose of the `ngon` function is to generate a regular polygon based on the specified number of sides and radius. In the case of the dodecahedron, it is used to create pentagonal faces, as a dodecahedron consists of 12 regular pentagons.\n\n2. **Sketching on a Plane**: The function starts by initiating a sketch on a given plane. This is crucial because the dodecahedron's faces need to be defined in a 3D space, and the plane parameter allows the function to determine where the pentagon will be drawn.\n\n3. **Iterative Line Drawing**: The function uses a loop to calculate the coordinates of each vertex of the polygon based on the number of sides and the radius. It employs trigonometric functions (cosine and sine) to determine the x and y coordinates of each vertex, effectively creating the shape of the polygon.\n\n4. **Closing the Polygon**: After defining all the vertices, the function closes the polygon by connecting the last vertex back to the first, ensuring that the shape is complete.\n\n### Utilization in Creating Pentagonal Faces\n\nIn the provided KCL code, the `ngon` function is utilized in two key places to create the pentagonal faces of the dodecahedron:\n\n1. **Bottom Face**:\n   ```kcl\n   bottom = extrude(wallThickness, ngon(\"XY\", 5, pentR))\n   ```\n   Here, the `ngon` function is called with the parameters:\n   - `\"XY\"`: This indicates that the pentagon will be drawn on the XY plane.\n   - `5`: This specifies that the polygon will have 5 sides, making it a pentagon.\n   - `pentR`: This is the radius of the pentagon, calculated earlier in the code.\n\n   The result of the `ngon` function is then extruded to create the thickness of the bottom face of the dodecahedron.\n\n2. **Bottom Angled Face**:\n   ```kcl\n   bottomSide = extrude(wallThickness, ngon(planeBottomSide, 5, pentR))\n   ```\n   In this case, the `ngon` function is called with a custom plane defined by `planeBottomSide`, which positions the pentagon at an angle appropriate for the dodecahedron's geometry. The same parameters for the number of sides and radius are used, ensuring that the pentagonal face is consistent with the bottom face.\n\n### Conclusion\n\nThe `ngon` function is a crucial component in the KCL code for constructing a hollow dodecahedron. It simplifies the process of creating regular pentagonal faces by encapsulating the logic for polygon generation, allowing for easy adjustments to the number of sides and dimensions. By utilizing this function, the code efficiently constructs the individual faces of the dodecahedron, which are then extruded and patterned to form the complete 3D shape."}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `rail8020` function in the KCL code, and how does it create an adjustable 80/20 extruded aluminum linear rail?"}, {"role": "assistant", "content": "// 80/20 Rail\n// An 80/20 extruded aluminum linear rail. T-slot profile adjustable by profile height, rail length, and origin position\n\n\n// Define function\nfn rail8020 = (originStart, railHeight, railLength) => {\n  // Sketch side 1 of profile\n  sketch001 = startSketchOn('-XZ')\n    |> startProfileAt([\n         originStart[0],\n         0.1 * railHeight + originStart[1]\n       ], %)\n    |> arc({\n         angleStart: 180,\n         angleEnd: 270,\n         radius: 0.1 * railHeight\n       }, %)\n    |> arc({\n         angleStart: 180,\n         angleEnd: 0,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> xLine(0.1 * railHeight, %)\n    |> arc({\n         angleStart: 180,\n         angleEnd: 0,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> xLine(0.06 * railHeight, %, $edge1)\n    |> yLine(0.087 * railHeight, %, $edge2)\n    |> xLine(-0.183 * railHeight, %, $edge3)\n    |> angledLineToY({\n         angle: 45,\n         to: (1 - 0.356) / 2 * railHeight + originStart[1]\n       }, %, $edge4)\n    |> xLine(0.232 * railHeight, %, $edge5)\n    |> angledLineToY({\n         angle: -45,\n         to: 0.087 * railHeight + originStart[1]\n       }, %, $edge6)\n    |> xLine(-0.183 * railHeight, %, $edge7)\n    |> yLine(-0.087 * railHeight, %, $edge8)\n    |> xLine(0.06 * railHeight, %)\n    |> arc({\n         angleStart: 180,\n         angleEnd: 0,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> xLine(0.1 * railHeight, %)\n    |> arc({\n         angleStart: 180,\n         angleEnd: 0,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> arc({\n         angleStart: -90,\n         angleEnd: 0,\n         radius: 0.1 * railHeight\n       }, %)\n\n    // Sketch side 2 of profile\n    |> arc({\n         angleStart: 270,\n         angleEnd: 90,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> yLine(0.1 * railHeight, %)\n    |> arc({\n         angleStart: 270,\n         angleEnd: 90,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> yLine(0.06 * railHeight, %, $edge9)\n    |> xLine(-0.087 * railHeight, %, $edge10)\n    |> yLine(-0.183 * railHeight, %, $edge11) // edge11\n    |> angledLineToX({\n         angle: 135,\n         to: ((1 - 0.356) / 2 + 0.356) * railHeight + originStart[0]\n       }, %, $edge12) // edge12\n    |> yLine(0.232 * railHeight, %, $edge13) // 13\n    |> angledLineToX({\n         angle: 45,\n         to: (1 - 0.087) * railHeight + originStart[0]\n       }, %, $edge14) // 14\n    |> yLine(-0.183 * railHeight, %, $edge15) // 15\n    |> xLine(0.087 * railHeight, %, $edge16)\n    |> yLine(0.06 * railHeight, %)\n    |> arc({\n         angleStart: 270,\n         angleEnd: 90,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> yLine(0.1 * railHeight, %)\n    |> arc({\n         angleStart: 270,\n         angleEnd: 90,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n\n    // Sketch side 3 of profile\n    |> arc({\n         angleStart: 0,\n         angleEnd: 90,\n         radius: 0.1 * railHeight\n       }, %)\n    |> arc({\n         angleStart: 0,\n         angleEnd: -180,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> xLine(-0.1 * railHeight, %)\n    |> arc({\n         angleStart: 0,\n         angleEnd: -180,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> xLine(-0.06 * railHeight, %, $edge17)\n    |> yLine(-0.087 * railHeight, %, $edge18)\n    |> xLine(0.183 * railHeight, %, $edge19)\n    |> angledLineToY({\n         angle: 45,\n         to: ((1 - 0.356) / 2 + 0.356) * railHeight + originStart[1]\n       }, %, $edge20)\n    |> xLine(-0.232 * railHeight, %, $edge21)\n    |> angledLineToY({\n         angle: 135,\n         to: (1 - 0.087) * railHeight + originStart[1]\n       }, %, $edge22)\n    |> xLine(0.183 * railHeight, %, $edge23)\n    |> yLine(0.087 * railHeight, %, $edge24)\n    |> xLine(-0.06 * railHeight, %)\n    |> arc({\n         angleStart: 0,\n         angleEnd: -180,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> xLine(-0.1 * railHeight, %)\n    |> arc({\n         angleStart: 0,\n         angleEnd: -180,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> arc({\n         angleStart: 90,\n         angleEnd: 180,\n         radius: 0.1 * railHeight\n       }, %)\n\n    // Sketch side 4 of profile\n    |> arc({\n         angleStart: 90,\n         angleEnd: -90,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> yLine(-0.1 * railHeight, %)\n    |> arc({\n         angleStart: 90,\n         angleEnd: -90,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> yLine(-0.06 * railHeight, %, $edge25)\n    |> xLine(0.087 * railHeight, %, $edge26)\n    |> yLine(0.183 * railHeight, %, $edge27)\n    |> angledLineToX({\n         angle: 135,\n         to: (1 - 0.356) / 2 * railHeight + originStart[0]\n       }, %, $edge28)\n    |> yLine(-0.232 * railHeight, %, $edge29)\n    |> angledLineToX({\n         angle: 45,\n         to: 0.087 * railHeight + originStart[0]\n       }, %, $edge30)\n    |> yLine(0.183 * railHeight, %, $edge31)\n    |> xLine(-0.087 * railHeight, %, $edge32)\n    |> yLine(-0.06 * railHeight, %)\n    |> arc({\n         angleStart: 90,\n         angleEnd: -90,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> yLine(-0.1 * railHeight, %)\n    |> arc({\n         angleStart: 90,\n         angleEnd: -90,\n         radius: 0.072 / 4 * railHeight\n       }, %)\n    |> close(%)\n\n    // Sketch center hole of profile\n    |> hole(circle({\n         center: [\n           .5 * railHeight + originStart[0],\n           .5 * railHeight + originStart[1]\n         ],\n         radius: .205 * railHeight / 2\n       }, %), %)\n    |> extrude(railLength, %)\n    |> fillet({\n         radius: 0.06,\n         tags: [\n           getNextAdjacentEdge(edge3),\n           getNextAdjacentEdge(edge4),\n           getNextAdjacentEdge(edge5),\n           getNextAdjacentEdge(edge6),\n           getNextAdjacentEdge(edge11),\n           getNextAdjacentEdge(edge12),\n           getNextAdjacentEdge(edge13),\n           getNextAdjacentEdge(edge14),\n           getNextAdjacentEdge(edge19),\n           getNextAdjacentEdge(edge20),\n           getNextAdjacentEdge(edge21),\n           getNextAdjacentEdge(edge22),\n           getNextAdjacentEdge(edge27),\n           getNextAdjacentEdge(edge28),\n           getNextAdjacentEdge(edge29),\n           getNextAdjacentEdge(edge30)\n         ]\n       }, %)\n    |> fillet({\n         radius: 0.03,\n         tags: [\n           getNextAdjacentEdge(edge1),\n           getNextAdjacentEdge(edge2),\n           getNextAdjacentEdge(edge7),\n           getNextAdjacentEdge(edge8),\n           getNextAdjacentEdge(edge9),\n           getNextAdjacentEdge(edge10),\n           getNextAdjacentEdge(edge15),\n           getNextAdjacentEdge(edge16),\n           getNextAdjacentEdge(edge17),\n           getNextAdjacentEdge(edge18),\n           getNextAdjacentEdge(edge23),\n           getNextAdjacentEdge(edge24),\n           getNextAdjacentEdge(edge25),\n           getNextAdjacentEdge(edge26),\n           getNextAdjacentEdge(edge31),\n           getNextAdjacentEdge(edge32)\n         ]\n       }, %)\n  return sketch001\n}\n\n// Generate one adjustable rail of 80/20\nrail8020([0, 0], 1.5, 48)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'a-parametric-bearing-pillow-block' file, and how does it achieve the creation of a parametric bearing pillow block?"}, {"role": "assistant", "content": "// A Parametric Bearing Pillow Block\n// A bearing pillow block, also known as a plummer block or pillow block bearing, is a pedestal used to provide support for a rotating shaft with the help of compatible bearings and various accessories. Housing a bearing, the pillow block provides a secure and stable foundation that allows the shaft to rotate smoothly within its machinery setup. These components are essential in a wide range of mechanical systems and machinery, playing a key role in reducing friction and supporting radial and axial loads.\n\n\n// Define constants such as length, width, height, counter-bore depth and diameter, bearing diameter, hole location padding, and more\nlength = 6\nwidth = 4\nheight = 1\ncbDepth = .25\ncbDia = .7\nholeDia = .375\npadding = 1.5\nbearingDia = 3\n\n// (Needs to be updated). Sketch the block and extrude up to where the counterbore diameter starts.\nblock = startSketchOn('XY')\n  |> startProfileAt([-width / 2, -length / 2], %)\n  |> lineTo([width / 2, -length / 2], %)\n  |> lineTo([width / 2, length / 2], %)\n  |> lineTo([-width / 2, length / 2], %)\n  |> close(%)\n  |> hole(circle({\n       center: [\n         -(width / 2 - (padding / 2)),\n         -(length / 2 - (padding / 2))\n       ],\n       radius: holeDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [\n         -(width / 2 - (padding / 2)),\n         length / 2 - (padding / 2)\n       ],\n       radius: holeDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width / 2 - (padding / 2),\n         length / 2 - (padding / 2)\n       ],\n       radius: holeDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width / 2 - (padding / 2),\n         -(length / 2 - (padding / 2))\n       ],\n       radius: holeDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: bearingDia / 2\n     }, %), %)\n  |> extrude(height - cbDepth, %)\n\n// Create a second sketch that creates the counterbore diameters and extrude the rest of the way to get the total height. Note: You cannot use startSketchOn(block, 'end'). The extrude lives outside the bounds, and the engine will not execute. This is a known issue.\nsecondHalf = startSketchOn({\n       plane: {\n         origin: { x: 0, y: 0, z: height - cbDepth },\n         xAxis: { x: 1, y: 0, z: 0 },\n         yAxis: { x: 0, y: 1, z: 0 },\n         zAxis: { x: 0, y: 0, z: 1 }\n       }\n     })\n  |> startProfileAt([-width / 2, -length / 2], %)\n  |> lineTo([width / 2, -length / 2], %)\n  |> lineTo([width / 2, length / 2], %)\n  |> lineTo([-width / 2, length / 2], %)\n  |> close(%)\n  |> hole(circle({\n       center: [\n         -(width / 2 - (padding / 2)),\n         -(length / 2 - (padding / 2))\n       ],\n       radius: cbDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [\n         -(width / 2 - (padding / 2)),\n         length / 2 - (padding / 2)\n       ],\n       radius: cbDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width / 2 - (padding / 2),\n         length / 2 - (padding / 2)\n       ],\n       radius: cbDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width / 2 - (padding / 2),\n         -(length / 2 - (padding / 2))\n       ],\n       radius: cbDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: bearingDia / 2\n     }, %), %)\n  |> extrude(cbDepth, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'ball-bearing' file, and how does it achieve the creation of a ball bearing model?"}, {"role": "assistant", "content": "// Ball Bearing\n// A ball bearing is a type of rolling-element bearing that uses balls to maintain the separation between the bearing races. The primary purpose of a ball bearing is to reduce rotational friction and support radial and axial loads. \n\n// Define constants like ball diameter, inside diamter, overhange length, and thickness\noutsideDiameter = 1.625 \nsphereDia = 0.25 \nshaftDia = 0.75 \noverallThickness = 0.313 \nwallThickness = 0.100 \noverHangLength = .3 \nnBalls = 10\nchainWidth = sphereDia/2 \nchainThickness = sphereDia/8 \nlinkDiameter = sphereDia/4 \n\ncustomPlane = {\n  plane: {\n    origin: { x: 0, y: 0, z: -overallThickness/2 },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 1, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n// Sketch the inside bearing piece\ninsideWallSketch = startSketchOn(customPlane)\n  |> circle({\n       center: [0, 0],\n       radius: shaftDia/2 + wallThickness\n     }, %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: shaftDia/2\n     }, %), %)\n\n// Extrude the inside bearing piece\ninsideWall = extrude(overallThickness, insideWallSketch)\n\n// Create the sketch of one of the balls\nballsSketch = startSketchOn(\"XY\")\n  |> startProfileAt([shaftDia/2 + wallThickness, 0.001], %)\n  |> arc({\n    angleEnd: 0,\n    angleStart: 180,\n    radius: sphereDia/2,\n  }, %)\n  |> close(%)\n\n// Revolve the ball to make a sphere and pattern around the inside wall\nballs = revolve({\n    axis: \"X\",\n  }, ballsSketch)\n  |> patternCircular3d({\n      arcDegrees: 360,\n      axis: [0, 0, 1],\n      center: [0, 0, 0],\n      instances: nBalls,\n      rotateDuplicates: true\n  }, %)\n\n// Create the sketch for the chain around the balls\nchainSketch = startSketchOn(\"XY\")\n  |> startProfileAt([shaftDia/2 + wallThickness + sphereDia/2 - chainWidth/2, 0.125 * sin(toRadians(60))], %)\n  |> arc({\n    angleEnd: 60,\n    angleStart: 120,\n    radius: sphereDia/2,\n  }, %)\n  |> line([0, chainThickness], %)\n  |> line([-chainWidth, 0], %)\n  |> close(%)\n\n// Revolve the chain sketch\nchainHead = revolve({\n    axis: \"X\",\n  }, chainSketch)\n  |> patternCircular3d({\n    arcDegrees: 360,\n    axis: [0, 0, 1],\n    center: [0, 0, 0],\n    instances: nBalls,\n    rotateDuplicates: true,\n  }, %)\n\n// Create the sketch for the links in between the chains \nlinkSketch = startSketchOn(\"XZ\")\n  |> circle({\n       center: [shaftDia/2 + wallThickness + sphereDia/2, 0],\n       radius: linkDiameter/2\n     }, %)\n\n// Revolve the link sketch\nlinkRevolve = revolve({\n    axis: 'Y',\n    angle: 360/nBalls\n  }, linkSketch)\n  |> patternCircular3d({\n    arcDegrees: 360,\n    axis: [0, 0, 1],\n    center: [0, 0, 0],\n    instances: nBalls,\n    rotateDuplicates: true,\n  }, %)\n\n// Create the sketch for the outside walls\noutsideWallSketch = startSketchOn(customPlane)\n  |> circle({\n       center: [0, 0],\n       radius: outsideDiameter/2\n     }, %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: shaftDia/2 + wallThickness + sphereDia\n     }, %), %)\n\noutsideWall = extrude(overallThickness, outsideWallSketch)\n\n// https://www.mcmaster.com/60355K185/"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'bracket' file, and how does it calculate the required thickness of the shelf bracket?"}, {"role": "assistant", "content": "// Shelf Bracket\n// This is a bracket that holds a shelf. It is made of aluminum and is designed to hold a force of 300 lbs. The bracket is 6 inches wide and the force is applied at the end of the shelf, 12 inches from the wall. The bracket has a factor of safety of 1.2. The legs of the bracket are 5 inches and 2 inches long. The thickness of the bracket is calculated from the constraints provided.\n\n// Define constants\nsigmaAllow = 35000 // psi (6061-T6 aluminum)\nwidth = 6 \np = 300 // Force on shelf - lbs\nfactorOfSafety = 1.2 // FOS of 1.2\nshelfMountL = 5 \nwallMountL = 2 \nshelfDepth = 12 // Shelf is 12 inches in depth from the wall\nmoment = shelfDepth * p // assume the force is applied at the end of the shelf to be conservative (lb-in)\n\nfilletRadius = .375 \nextFilletRadius = .25 \nmountingHoleDiameter = 0.5 \n\n// Calculate required thickness of bracket\nthickness = sqrt(moment * factorOfSafety * 6 / (sigmaAllow * width)) // this is the calculation of two brackets holding up the shelf (inches)\n\n// Sketch the bracket body and fillet the inner and outer edges of the bend\nbracketLeg1Sketch = startSketchOn('XY')\n  |> startProfileAt([0, 0], %)\n  |> line([shelfMountL-filletRadius, 0], %, $fillet1)\n  |> line([0, width], %, $fillet2)\n  |> line([-shelfMountL + filletRadius, 0], %)\n  |> close(%)\n  |> hole(circle({center: [1, 1], radius: mountingHoleDiameter/2}, %), %)\n  |> hole(circle({center: [shelfMountL-1.5, width-1], radius: mountingHoleDiameter/2}, %), %)\n  |> hole(circle({center: [1, width-1], radius: mountingHoleDiameter/2}, %), %)\n  |> hole(circle({center: [shelfMountL-1.5, 1], radius: mountingHoleDiameter/2}, %), %)\n\n// Extrude the leg 2 bracket sketch\nbracketLeg1Extrude = extrude(thickness, bracketLeg1Sketch)\n  |> fillet({\n    radius: extFilletRadius,\n    tags: [\n      getNextAdjacentEdge(fillet1),\n      getNextAdjacentEdge(fillet2)\n    ],\n  }, %)\n\n// Sketch the fillet arc\nfilletSketch = startSketchOn('XZ')\n  |> startProfileAt([0, 0], %)\n  |> line([0, thickness], %)\n  |> arc({\n    angleEnd: 180,\n    angleStart: 90,\n    radius: filletRadius + thickness,\n  }, %)\n  |> line([thickness, 0], %)\n  |> arc({\n    angleEnd: 90,\n    angleStart: 180,\n    radius: filletRadius,\n  }, %)\n\n// Sketch the bend\nfilletExtrude = extrude(-width, filletSketch)\n\n// Create a custom plane for the leg that sits on the wall\ncustomPlane = {\n  plane: {\n    origin: { x: -filletRadius, y: 0, z: 0 },\n    xAxis: { x: 0, y: 1, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 1, y: 0, z: 0 }\n  }\n}\n\n// Create a sketch for the second leg\nbracketLeg2Sketch = startSketchOn(customPlane)\n  |> startProfileAt([0, -filletRadius], %)\n  |> line([width, 0], %)\n  |> line([0, -wallMountL], %, $fillet3)\n  |> line([-width, 0], %, $fillet4)\n  |> close(%)\n  |> hole(circle({center: [1, -1.5], radius: mountingHoleDiameter / 2}, %), %)\n  |> hole(circle({center: [5, -1.5], radius: mountingHoleDiameter / 2}, %), %)\n\n// Extrude the second leg\nbracketLeg2Extrude = extrude(-thickness, bracketLeg2Sketch)\n  |> fillet({\n    radius: extFilletRadius,\n    tags: [\n      getNextAdjacentEdge(fillet3),\n      getNextAdjacentEdge(fillet4)\n    ],\n  }, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'brake-caliper' file, and how does it achieve the design of a brake caliper?"}, {"role": "assistant", "content": "// Brake Caliper\n// Brake calipers are used to squeeze the brake pads against the rotor, causing larger and larger amounts of friction depending on how hard the brakes are pressed.\n\n// Define constants\nrotorDiameter = 12 \nrotorInnerDiameterThickness = 12.6 \nrotorTotalThickness = 25.4 \ncaliperTolerance = 5 \ncaliperPadLength = 40 \ncaliperThickness = 10 \ncaliperOuterEdgeRadius = 10 \ncaliperInnerEdgeRadius = 3 \n\n// Create the plane for the brake caliper. This is so it can match up with the rotor model.\nbrakeCaliperPlane = {\n  plane: {\n    origin: { x: 0, y: 0, z: 0 },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 1, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n// Sketch the brake caliper cross section\nbrakeCaliperSketch = startSketchOn(brakeCaliperPlane)\n  |> startProfileAt([rotorDiameter/2 * 25.4+caliperTolerance, 0], %)\n  |> line([0, rotorTotalThickness + caliperTolerance - caliperInnerEdgeRadius], %)\n  |> tangentialArc({\n    offset: 90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([-caliperPadLength + 2 * caliperInnerEdgeRadius, 0], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([0, caliperThickness - caliperInnerEdgeRadius * 2], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([caliperPadLength + caliperThickness - caliperOuterEdgeRadius - caliperInnerEdgeRadius, 0], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperOuterEdgeRadius,\n  }, %)\n  |> line([0, -2*caliperTolerance-2*caliperThickness-rotorTotalThickness + 2 * caliperOuterEdgeRadius], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperOuterEdgeRadius,\n  }, %)\n  |> line([-caliperPadLength - caliperThickness + caliperOuterEdgeRadius + caliperInnerEdgeRadius, 0], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([0, caliperThickness - 2 * caliperInnerEdgeRadius], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([caliperPadLength - 2 * caliperInnerEdgeRadius, 0], %)\n  |> tangentialArc({\n    offset: 90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> close(%)\n\n// Revolve the brake caliiper sketch\nbrakeCaliper = revolve({\n    axis: \"Y\",\n    angle: -70,\n  }, brakeCaliperSketch)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'car-wheel' file, and how does it create a sports car wheel with specific features such as lug patterns and spokes?"}, {"role": "assistant", "content": "// Car Wheel\n// A sports car wheel with a circular lug pattern and spokes.\n\n\n// Define constants\n// Base units for this model are in inches\nlugCount = 5\nlugSpacing = 114.3 * mm()\noffset = -35 * mm()\nbackSpacing = 6.38\nwheelWidth = 9.5\nwheelDiameter = 19\nspokeCount = 6\nspokeGap = 0.2\nspokeAngle = 0.02\nspokeThickness = 0.95\n\n// Create the wheel center\nlugBase = startSketchOn('XZ')\n  |> circle({\n       center: [0, 0],\n       radius: (lugSpacing + 1.5) / 2\n     }, %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: (lugSpacing - 1.5) / 2\n     }, %), %)\n  |> extrude(wheelWidth / 20, %)\n\n// Extend the wheel center and bore holes to accomidate the lug heads\nlugExtrusion = startSketchOn(lugBase, 'END')\n  |> circle({\n       center: [0, 0],\n       radius: (lugSpacing + 1.5) / 2\n     }, %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: (lugSpacing - 1.5) / 2\n     }, %), %)\n  |> extrude(wheelWidth / 10, %)\n\n// Create the circular pattern for the lugs\nlugClearance = startSketchOn(lugExtrusion, 'END')\n  |> circle({\n       center: [lugSpacing / 2, 0],\n       radius: 1.2 / 2\n     }, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: lugCount,\n       rotateDuplicates: true\n     }, %)\n  |> extrude(-wheelWidth / 10, %)\n\n// Create the circular pattern for the lug holes\nlugHoles = startSketchOn(lugBase, 'END')\n  |> circle({\n       center: [lugSpacing / 2, 0],\n       radius: 16 * mm() / 2\n     }, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: lugCount,\n       rotateDuplicates: true\n     }, %)\n  |> extrude(-wheelWidth / 20, %)\n\n// Add detail to the wheel center by revolving curved edge profiles\nwheelCenterInner = startSketchOn('XY')\n  |> startProfileAt([(lugSpacing - 1.5) / 2, 0], %)\n  |> yLine(-wheelWidth / 10 - (wheelWidth / 20), %)\n  |> bezierCurve({\n       to: [-0.4, 0.3],\n       control1: [-0.3, 0],\n       control2: [0, 0.3]\n     }, %)\n  |> yLineTo(0, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\nwheelCenterOuter = startSketchOn('XY')\n  |> startProfileAt([(lugSpacing + 1.5) / 2, 0], %)\n  |> yLine(-wheelWidth / 10 - (wheelWidth / 20), %)\n  |> bezierCurve({\n       to: [0.4, -0.1],\n       control1: [0.3, 0],\n       control2: [0.2, -0.3]\n     }, %)\n  |> yLineTo(-wheelWidth / 20, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\n// Write a function that defines the spoke geometry, patterns and extrudes it\nfn spoke = (spokeGap, spokeAngle, spokeThickness) => {\n  // Seperating the spoke base planes\n  plane001 = {\n    plane: {\n      origin: [0.0, 0.0, spokeGap / 2],\n      xAxis: [1.0, 0.0, spokeAngle],\n      yAxis: [0.0, 1.0, 0.0],\n      zAxis: [0.0, 0.0, 1.0]\n    }\n  }\n\n  // Spoke cross sections\n  spokeProfile = startSketchOn(plane001)\n    |> startProfileAt([(lugSpacing + 2) / 2, -0.7], %)\n    |> bezierCurve({\n         to: [\n           (wheelDiameter - lugSpacing - 2.9) / 2,\n           offset\n         ],\n         control1: [\n           (wheelDiameter - lugSpacing - 2.9) / 3.5,\n           offset / 7\n         ],\n         control2: [\n           (wheelDiameter - lugSpacing - 2.9) / 4,\n           offset / 1.5\n         ]\n       }, %)\n    |> yLine(-wheelWidth / 15, %)\n    |> bezierCurve({\n         to: [\n           -(wheelDiameter - lugSpacing - 2.9) / 2,\n           -offset\n         ],\n         control1: [\n           -(wheelDiameter - lugSpacing - 2.9) / 5,\n           -offset / 7\n         ],\n         control2: [\n           -(wheelDiameter - lugSpacing - 2.9) / 5,\n           -offset / 1.5\n         ]\n       }, %)\n    |> lineTo([profileStartX(%), profileStartY(%)], %)\n    |> close(%)\n\n  // Circular pattern spokes\n  spokePattern = extrude(spokeThickness, spokeProfile)\n    |> patternCircular3d({\n         axis: [0, 1, 0],\n         center: [0, -2000, 0],\n         instances: spokeCount,\n         arcDegrees: 360,\n         rotateDuplicates: true\n       }, %)\n\n  return spokePattern\n}\n\nspoke(spokeGap, spokeAngle, spokeThickness)\nspoke(-spokeGap, -spokeAngle, -spokeThickness)\n\n// Define and revolve wheel exterior\nwheelOuterRevolve = startSketchOn('XY')\n  |> startProfileAt([\n       wheelDiameter / 2,\n       -wheelWidth + backSpacing + offset\n     ], %)\n  |> yLine(wheelWidth * 0.25, %)\n  |> line([-wheelWidth * 0.02, wheelWidth * 0.02], %)\n  |> yLine(wheelWidth * 0.25, %)\n  |> line([wheelWidth * 0.02, wheelWidth * 0.02], %)\n  |> yLineTo(backSpacing + offset, %)\n  |> line([wheelWidth * 0.05, wheelWidth * .01], %)\n  |> yLine(wheelWidth * 0.05, %)\n  |> xLine(-wheelWidth * 0.03, %)\n  |> yLine(-wheelWidth * 0.02, %)\n  |> line([-wheelWidth * 0.05, -wheelWidth * 0.01], %)\n  |> yLine(-backSpacing * 0.7, %)\n  |> line([\n       -wheelDiameter * 0.01,\n       -wheelWidth * 0.02\n     ], %)\n  |> yLineTo(offset - 0.2, %)\n  |> line([\n       -wheelDiameter * 0.03,\n       -wheelWidth * 0.02\n     ], %)\n  |> yLine(-wheelWidth * 0.02, %)\n  |> line([\n       wheelDiameter * 0.03,\n       -wheelWidth * 0.1\n     ], %)\n  |> yLine(-wheelWidth * 0.05, %)\n  |> line([wheelWidth * 0.02, -wheelWidth * 0.02], %)\n  |> yLineTo(-wheelWidth + backSpacing + offset - 0.28, %)\n  |> line([wheelWidth * 0.05, -wheelWidth * 0.01], %)\n  |> yLine(-wheelWidth * 0.02, %)\n  |> xLine(wheelWidth * 0.03, %)\n  |> yLine(wheelWidth * 0.05, %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'car-wheel-assembly' file, and how does it achieve the creation of a car wheel assembly, including components like the rotor, tire, and lug nuts?"}, {"role": "assistant", "content": "// Car Wheel Assembly\n// A car wheel assembly with a rotor, tire, and lug nuts.\n\n\n// Car Wheel\n// A sports car wheel with a circular lug pattern and spokes.\n\n// Define constants\nlugCount = 5\nlugSpacing = 114.3 \noffset = -35 \nbackSpacing = 6.38 \nwheelWidth = 9.5 \nwheelDiameter = 19 \n\n\n// Create the circular pattern for the lug holes\ncircles = startSketchOn('XZ')\n  |> circle({center: [lugSpacing / 2, 0], radius: 16 / 2}, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: lugCount,\n       rotateDuplicates: true\n     }, %)\n\n// Create the wheel center and add lug holes\nflangeBase = startSketchOn('XZ')\n  |> circle({center: [0, 0], radius: lugSpacing / 2 + 16 + 5}, %)\n  |> hole(circles, %)\n  |> extrude(10, %)\n\n// Remove the interior of the wheel center\nsketch001 = startSketchOn(flangeBase, 'END')\n  |> circle({center: [0, 0], radius: 20}, %)\n  |> extrude(-10, %)\n\n// Add more material to the wheel center\nsketch002 = startSketchOn(flangeBase, 'END')\n  |> circle({center: [0, 0], radius: lugSpacing / 2 + 16 + 8}, %)\n  |> extrude(30, %)\n\n// Edge treatment around center\nsketch003 = startSketchOn('XY')\n  |> startProfileAt([lugSpacing / 2 + 16 + 8, -10 - 30], %)\n  |> yLine(30, %)\n  |> line([6, -2], %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\n// Center cap\nsketch004 = startSketchOn('XY')\n  |> startProfileAt([15, -40], %)\n  |> xLine(15, %)\n  |> line([-3.01, -3.54], %)\n  |> line([-8.8, 0.17], %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\n// Holes for lug nut heads\nsketch005 = startSketchOn(sketch002, 'END')\n  |> circle({center: [lugSpacing / 2, 0], radius: 17}, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: lugCount,\n       rotateDuplicates: true\n     }, %)\n\nsketch006 = extrude(-30, sketch005)\n\n// Seperating the spoke base planes\nplane001 = {\n  plane: {\n    origin: [0.0, 0.0, 5.0],\n    xAxis: [1.0, 0.0, 0.0],\n    yAxis: [0.0, 1.0, 0.0],\n    zAxis: [0.0, 0.0, 1.0]\n  }\n}\n\nplane002 = {\n  plane: {\n    origin: [0.0, 0.0, -5.0],\n    xAxis: [1.0, 0.0, 0.0],\n    yAxis: [0.0, 1.0, 0.0],\n    zAxis: [0.0, 0.0, 1.0]\n  }\n}\n\n// Spoke cross sections\nsketch007 = startSketchOn(plane001)\n  |> startProfileAt([lugSpacing / 2 + 17, -36], %)\n  |> bezierCurve({\n       to: [\n         wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 35,\n         12\n       ],\n       control1: [\n         (wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 35) / 2,\n         0\n       ],\n       control2: [\n         (wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 35) / 2,\n         15\n       ]\n     }, %)\n  |> yLine(12, %)\n  |> bezierCurve({\n       to: [\n         -wheelDiameter * 25.4 / 2 + lugSpacing / 2 + 35,\n         -12\n       ],\n       control1: [\n         -(wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 16) / 2,\n         0\n       ],\n       control2: [\n         -(wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 16) / 2,\n         -15\n       ]\n     }, %)\n  |> close(%)\n\nsketch008 = startSketchOn(plane002)\n  |> startProfileAt([lugSpacing / 2 + 17, -36], %)\n  |> bezierCurve({\n       to: [\n         wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 35,\n         12\n       ],\n       control1: [\n         (wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 35) / 2,\n         0\n       ],\n       control2: [\n         (wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 35) / 2,\n         15\n       ]\n     }, %)\n  |> yLine(12, %)\n  |> bezierCurve({\n       to: [\n         -wheelDiameter * 25.4 / 2 + lugSpacing / 2 + 35,\n         -12\n       ],\n       control1: [\n         -(wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 16) / 2,\n         0\n       ],\n       control2: [\n         -(wheelDiameter * 25.4 / 2 - (lugSpacing / 2) - 16) / 2,\n         -15\n       ]\n     }, %)\n  |> close(%)\n\n// Circular pattern spokes\nsketch009 = extrude(20, sketch007)\n  |> patternCircular3d({\n       axis: [0, 1, 0],\n       center: [0, -2000, 0],\n       instances: 6,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nsketch0010 = extrude(-20, sketch008)\n  |> patternCircular3d({\n       axis: [0, 1, 0],\n       center: [0, -2000, 0],\n       instances: 6,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\n// Wheel exterior\nsketch0011 = startSketchOn('XY')\n  |> startProfileAt([\n       wheelDiameter * 25.4 / 2,\n       -wheelWidth * 25.4 + backSpacing * 25.4 + offset\n     ], %)\n  |> line([wheelWidth * 2, -wheelWidth], %)\n  |> yLine(-wheelWidth * 2, %)\n  |> xLine(-wheelWidth, %)\n  |> yLine(wheelWidth * 1.5, %)\n  |> line([-wheelWidth * 2, wheelWidth], %)\n  |> yLine(wheelWidth * 2.7, %)\n  |> line([-wheelWidth, wheelWidth], %)\n  |> yLine(wheelWidth * 9, %)\n  |> line([wheelWidth, wheelWidth], %)\n  |> yLine(wheelWidth * 11, %)\n  |> line([wheelWidth * 2, wheelWidth], %)\n  |> yLine(wheelWidth * 2, %)\n  |> xLine(wheelWidth, %)\n  |> yLine(-wheelWidth * 2.7, %)\n  |> line([-wheelWidth * 2, -wheelWidth], %)\n  |> yLine(-wheelWidth * 11, %)\n  |> line([-wheelWidth, -wheelWidth], %)\n  |> yLine(-wheelWidth * 7.7, %)\n  |> line([wheelWidth, -wheelWidth], %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\n  \nrotorDiameter = 12 \nrotorInnerDiameter = 6 \nrotorSinglePlateThickness = 6.3 \nrotorInnerDiameterThickness = 12.6 \nlugHolePatternDia = 3 \nyAxisOffset = 10 \nrotorTotalThickness = 25.4 \nspacerPatternDiameter = 11 \nspacerDiameter = 6.3 \nspacerLength = rotorTotalThickness - 2*rotorSinglePlateThickness\nspacerCount = 16\nwheeldiameter = 19 \n\nrotorPlane = {\n  plane: {\n    origin: { x: 0, y: yAxisOffset, z: 0 },\n    xAxis: { x: -1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 0, y: 1, z: 0 }\n  }\n}\n\nfn lugPattern = (plane) => {\n  lugHolePattern = circle({center: [-lugSpacing/2, 0], radius: 8}, plane)\n  |> patternCircular2d({\n    arcDegrees: 360,\n    center: [0, 0],\n    instances: lugCount,\n    rotateDuplicates: true,\n  }, %)\n  return lugHolePattern\n}\n\nrotorSketch = startSketchOn(rotorPlane)\n  |> circle({center: [0, 0], radius: rotorDiameter/2 * 25.4}, %)\n  |> hole(lugPattern(%), %)\n  \nrotor = extrude(rotorSinglePlateThickness, rotorSketch)\n\nrotorBumpSketch = startSketchOn(rotorPlane)\n  |> circle({center: [0, 0], radius: rotorInnerDiameter/2 * 25.4}, %)\n  |> hole(lugPattern(%), %)\n  \nrotorBump = extrude(-rotorInnerDiameterThickness, rotorBumpSketch)\n\nrotorSecondaryPlatePlane = {\n  plane: {\n    origin: { x: 0, y: 10 + rotorTotalThickness*0.75, z: 0 },\n    xAxis: { x: -1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 0, y: 1, z: 0 }\n  }\n}\n\nsecondaryRotorSketch = startSketchOn(rotorSecondaryPlatePlane)\n  |> circle({center: [0, 0], radius: rotorDiameter/2 * 25.4}, %)\n  |> hole(lugPattern(%), %)\n\nsecondRotor = extrude(rotorSinglePlateThickness, secondaryRotorSketch)\n\nspacerSketch = startSketchOn(rotorSecondaryPlatePlane)\n  |> circle({center: [spacerPatternDiameter/2 * 25.4, 0], radius: spacerDiameter}, %)\n  |> patternCircular2d({\n    arcDegrees: 360,\n    center: [0, 0],\n    instances: spacerCount + 1,\n    rotateDuplicates: true,\n  }, %)\n\nspacers = extrude(-spacerLength, spacerSketch)\n\n// Lug Nut\n// lug Nuts are essential components used to create secure connections, whether for electrical purposes, like terminating wires or grounding, or for mechanical purposes, such as providing mounting points or reinforcing structural joints. \n\n\n// Define constants\nlugDiameter = 24 \nlugHeadLength = lugDiameter * .5 \nlugThreadDiameter = lugDiameter/2 * .85 //mm\nlugLength = 30 //mm\nlugThreadDepth = lugLength - 12.7 //mm\n\n// Define the plane the lugs live on\ncustomPlane = {\n      plane: {\n        origin: { x: lugSpacing/2, y: -30, z: 0 },\n        xAxis: { x: 1, y: 0, z: 0 },\n        yAxis: { x: 0, y: -1, z: 0 },\n        zAxis: { x: 0, y: 0, z: 1 }\n      }\n    }\n\n// Create a function for the lug nuts\nfn lug = (plane, length, diameter) => {\n\n    lugSketch = startSketchOn(customPlane)\n      |> startProfileAt([0 + diameter/2, 0], %)\n      |> angledLineOfYLength({\n        angle: 70,\n        length: lugHeadLength,\n      }, %)\n      |> xLineTo(lugDiameter/2, %)\n      |> yLineTo(lugLength, %)\n      |> tangentialArc({\n        offset: 90,\n        radius: 3,\n      }, %)\n      |> xLineTo(0+.001, %, $c1)\n      |> yLineTo(lugThreadDepth, %)\n      |> xLineTo(lugThreadDiameter, %)\n      |> yLineTo(0, %)\n      |> close(%)\n      |> revolve({\n        axis: \"Y\",\n      }, %)\n    return lugSketch\n}\n\nlug(customPlane, lugLength, lugDiameter)\n  |> patternCircular3d({\n      arcDegrees: 360,\n      axis: [0, 1, 0],\n      center: [0, 0, 0],\n      instances: 5,\n      rotateDuplicates: false,\n    }, %)\n\n// Tire\n// A tire is a critical component of a vehicle that provides the necessary traction and grip between the car and the road. It supports the vehicle's weight and absorbs shocks from road irregularities.\n\n\n// Define constants\ntireInnerDiameter = 19 * 25.4 \ntireOuterDiameter = 26 * 25.4 \ntireDepth = 280 \nbendRadius = 40 \ntireTreadWidth = 10 \ntireTreadDepth = 10 \ntireTreadOffset = 80 \n\n// Create the sketch of the tire\ntireSketch = startSketchOn(\"XY\")\n  |> startProfileAt([tireInnerDiameter / 2, tireDepth / 2], %)\n  |> lineTo([tireOuterDiameter / 2 - bendRadius, tireDepth / 2], %, $edge1)\n  |> tangentialArc({\n    offset: -90,\n    radius: bendRadius,\n  }, %)\n  |> lineTo([tireOuterDiameter / 2, tireDepth/2 - tireTreadOffset], %)\n  |> line([-tireTreadDepth, 0], %)\n  |> line([0, -tireTreadWidth], %)\n  |> line([tireTreadDepth, 0], %)\n  |> lineTo([tireOuterDiameter / 2, -tireDepth/2 + tireTreadOffset + tireTreadWidth], %)\n  |> line([-tireTreadDepth, 0], %)\n  |> line([0, -tireTreadWidth], %)\n  |> line([tireTreadDepth, 0], %)\n  |> lineTo([tireOuterDiameter / 2, -tireDepth / 2 + bendRadius], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: bendRadius,\n  }, %)\n  |> lineTo([tireInnerDiameter / 2, -tireDepth / 2], %, $edge2)\n  |> close(%)\n  \ntire = revolve({ axis: \"Y\" }, tireSketch)\n\n// Brake Caliper\n// Brake calipers are used to squeeze the brake pads against the rotor, causing larger and larger amounts of friction depending on how hard the brakes are pressed.\n\n// Define constants\ncaliperTolerance = 5 \ncaliperPadLength = 40 \ncaliperThickness = 10 \ncaliperOuterEdgeRadius = 10 \ncaliperInnerEdgeRadius = 3 \n\n// Create the plane for the brake caliper. This is so it can match up with the rotor model.\nbrakeCaliperPlane = {\n  plane: {\n    origin: { x: 0, y: 0, z: 0 },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 1, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n// Sketch the brake caliper profile\nbrakeCaliperSketch = startSketchOn(brakeCaliperPlane)\n  |> startProfileAt([rotorDiameter/2 * 25.4+caliperTolerance, 0], %)\n  |> line([0, rotorTotalThickness + caliperTolerance - caliperInnerEdgeRadius], %)\n  |> tangentialArc({\n    offset: 90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([-caliperPadLength + 2 * caliperInnerEdgeRadius, 0], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([0, caliperThickness - caliperInnerEdgeRadius * 2], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([caliperPadLength + caliperThickness - caliperOuterEdgeRadius - caliperInnerEdgeRadius, 0], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperOuterEdgeRadius,\n  }, %)\n  |> line([0, -2*caliperTolerance-2*caliperThickness-rotorTotalThickness + 2 * caliperOuterEdgeRadius], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperOuterEdgeRadius,\n  }, %)\n  |> line([-caliperPadLength - caliperThickness + caliperOuterEdgeRadius + caliperInnerEdgeRadius, 0], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([0, caliperThickness - 2 * caliperInnerEdgeRadius], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> line([caliperPadLength - 2 * caliperInnerEdgeRadius, 0], %)\n  |> tangentialArc({\n    offset: 90,\n    radius: caliperInnerEdgeRadius,\n  }, %)\n  |> close(%)\n\n// Revolve the brake caliiper sketch\nbrakeCaliper = revolve({\n    axis: \"Y\",\n    angle: -70,\n  }, brakeCaliperSketch)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'dodecahedron' file, and how does it achieve the construction of a hollow dodecahedron?"}, {"role": "assistant", "content": "// Hollow Dodecahedron\n// A regular dodecahedron or pentagonal dodecahedron is a dodecahedron composed of regular pentagonal faces, three meeting at each vertex. This example shows constructing the individual faces of the dodecahedron and extruding inwards.\n\n// Input parameters\n// circumscribed radius\ncircR = 25\n\n// Calculated parameters\n// thickness of the dodecahedron\nwallThickness = circR * 0.2\n\n// angle between faces in radians\ndihedral = acos(-(sqrt(5) / 5))\n\n// inscribed radius\ninscR = circR / 15 * sqrt(75 + 30 * sqrt(5))\n\n// pentagon edge length\nedgeL = 4 * circR / (sqrt(3) * (1 + sqrt(5)))\n\n// pentagon radius\npentR = edgeL / 2 / sin(toRadians(36))\n\n// define a function for a polygon\nfn ngon = (plane, numSides, radius) => {\n  step = 1 / numSides * tau()\n  sketch001 = startSketchOn(plane)\n    |> startProfileAt([cos(0) * radius, sin(0) * radius], %)\n  return reduce([1..numSides], sketch001, (i, sg) => {\n    x = cos(step * i) * radius\n    y = sin(step * i) * radius\n    return lineTo([x, y], sg)\n})\n  |> close(%)\n}\n\n// Define a plane for the bottom angled face\nplaneBottomSide = {\n  plane: {\n    origin: [\n      -inscR * cos(toRadians(toDegrees(dihedral) - 90)),\n      0,\n      inscR - inscR * sin(toRadians(toDegrees(dihedral) - 90))\n    ],\n    xAxis: [cos(dihedral), 0.000000, sin(dihedral)],\n    yAxis: [0, 1, 0],\n    zAxis: [sin(dihedral), 0, -cos(dihedral)]\n  }\n}\n\n// Extrude the faces in each plane\nbottom = extrude(wallThickness, ngon(\"XY\", 5, pentR))\nbottomSide = extrude(wallThickness, ngon(planeBottomSide, 5, pentR))\n\n// Pattern the sides so we have a full dodecahedron\nbottomBowl = patternCircular3d({\n  instances: 5,\n  axis: [0, 0, 1],\n  center: [0, 0, 0],\n  arcDegrees: 360,\n  rotateDuplicates: true\n}, bottomSide)\n\n// pattern the bottom to create the top face\npatternCircular3d({\n  instances: 2,\n  axis: [0, 1, 0],\n  center: [0, 0, inscR],\n  arcDegrees: 360,\n  rotateDuplicates: true\n}, bottom)\n\n// pattern the bottom angled faces to create the top\npatternCircular3d({\n  instances: 2,\n  axis: [0, 1, 0],\n  center: [0, 0, inscR],\n  arcDegrees: 360,\n  rotateDuplicates: true\n}, bottomBowl)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'enclosure' file, and how does it achieve the creation of a box with a sealing lid for storing items?"}, {"role": "assistant", "content": "// Enclosure\n// An enclosure body and sealing lid for storing items\n\n\nlength = 175\nwidth = 125\nheight = 70\nwallThickness = 3\nholeDia = 4\n\n// Model a box with base enclosure dimensions\nsketch001 = startSketchOn('XY')\n  |> startProfileAt([0, 0], %)\n  |> angledLine([0, width], %, $rectangleSegmentA001)\n  |> angledLine([\n       segAng(rectangleSegmentA001) + 90,\n       length\n     ], %, $rectangleSegmentB001)\n  |> angledLine([\n       segAng(rectangleSegmentA001),\n       -segLen(rectangleSegmentA001)\n     ], %, $rectangleSegmentC001)\n  |> lineTo([profileStartX(%), profileStartY(%)], %, $rectangleSegmentD001)\n  |> close(%)\nextrude001 = extrude(height, sketch001)\n  |> fillet({\n       radius: wallThickness * 4,\n       tags: [\n         getNextAdjacentEdge(rectangleSegmentA001),\n         getNextAdjacentEdge(rectangleSegmentB001),\n         getNextAdjacentEdge(rectangleSegmentC001),\n         getNextAdjacentEdge(rectangleSegmentD001)\n       ]\n     }, %)\n\n  // Apply a shell to the enclosure base to create the internal storage\n  |> shell({\n       faces: [\"end\"],\n       thickness: wallThickness\n     }, %)\n\n// Define a function to create the internal structure to secure a fastener at each corner\nfn function001 = (originStart) => {\n  // Create a plane to sketch on shell interior\n  plane001 = {\n    plane: {\n      origin: [0.0, 0.0, wallThickness],\n      xAxis: [1.0, 0.0, 0.0],\n      yAxis: [0.0, 1.0, 0.0],\n      zAxis: [0.0, 0.0, 1.0]\n    }\n  }\n\n  // Create a pillar with a fasterner hole at the center\n  sketch002 = startSketchOn(plane001)\n    |> circle({center: [originStart[0], originStart[1]], radius: holeDia + wallThickness}, %)\n    |> hole(circle({center: [originStart[0], originStart[1]], radius: holeDia}, %), %)\n  extrude002 = extrude(height - wallThickness, sketch002)\n\n  return extrude002\n}\n\n// Place the internal pillar at each corner\nfunction001([\n  wallThickness * 3 + holeDia,\n  wallThickness * 3 + holeDia\n])\nfunction001([\n  wallThickness * 3 + holeDia,\n  length - (wallThickness * 3 + holeDia)\n])\nfunction001([\n  width - (wallThickness * 3 + holeDia),\n  wallThickness * 3 + holeDia\n])\nfunction001([\n  width - (wallThickness * 3 + holeDia),\n  length - (wallThickness * 3 + holeDia)\n])\n\n// Define lid position and outer surface\nsketch003 = startSketchOn('XY')\n  |> startProfileAt([width * 1.2, 0], %)\n  |> angledLine([0, width], %, $rectangleSegmentA002)\n  |> angledLine([\n       segAng(rectangleSegmentA001) + 90,\n       length\n     ], %, $rectangleSegmentB002)\n  |> angledLine([\n       segAng(rectangleSegmentA001),\n       -segLen(rectangleSegmentA001)\n     ], %, $rectangleSegmentC002)\n  |> lineTo([profileStartX(%), profileStartY(%)], %, $rectangleSegmentD002)\n  |> close(%)\n  |> hole(circle({\n       center: [\n         width * 1.2 + wallThickness * 3 + holeDia,\n         wallThickness * 3 + holeDia\n       ],\n       radius: holeDia\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width * 1.2 + wallThickness * 3 + holeDia,\n         length - (wallThickness * 3 + holeDia)\n       ],\n       radius: holeDia\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width * 2.2 - (wallThickness * 3 + holeDia),\n         wallThickness * 3 + holeDia\n       ],\n       radius: holeDia\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width * 2.2 - (wallThickness * 3 + holeDia),\n         length - (wallThickness * 3 + holeDia)\n       ],\n       radius: holeDia\n     }, %), %)\nextrude003 = extrude(wallThickness, sketch003)\n  |> fillet({\n       radius: wallThickness * 4,\n       tags: [\n         getNextAdjacentEdge(rectangleSegmentA002),\n         getNextAdjacentEdge(rectangleSegmentB002),\n         getNextAdjacentEdge(rectangleSegmentC002),\n         getNextAdjacentEdge(rectangleSegmentD002)\n       ]\n     }, %)\n\n// Define lid inner and sealing surfaces\nsketch004 = startSketchOn(extrude003, 'END')\n  |> startProfileAt([\n       width * 1.2 + wallThickness,\n       wallThickness\n     ], %)\n  |> angledLine([0, width - (2 * wallThickness)], %, $rectangleSegmentA003)\n  |> angledLine([\n       segAng(rectangleSegmentA003) + 90,\n       length - (2 * wallThickness)\n     ], %, $rectangleSegmentB003)\n  |> angledLine([\n       segAng(rectangleSegmentA003),\n       -segLen(rectangleSegmentA003)\n     ], %, $rectangleSegmentC003)\n  |> lineTo([profileStartX(%), profileStartY(%)], %, $rectangleSegmentD003)\n  |> close(%)\n  |> hole(circle({\n       center: [\n         width * 1.2 + wallThickness * 3 + holeDia,\n         wallThickness * 3 + holeDia\n       ],\n       radius: holeDia + wallThickness\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width * 1.2 + wallThickness * 3 + holeDia,\n         length - (wallThickness * 3 + holeDia)\n       ],\n       radius: holeDia + wallThickness\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width * 2.2 - (wallThickness * 3 + holeDia),\n         wallThickness * 3 + holeDia\n       ],\n       radius: holeDia + wallThickness\n     }, %), %)\n  |> hole(circle({\n       center: [\n         width * 2.2 - (wallThickness * 3 + holeDia),\n         length - (wallThickness * 3 + holeDia)\n       ],\n       radius: holeDia + wallThickness\n     }, %), %)\nextrude004 = extrude(wallThickness, sketch004)\n  |> fillet({\n       radius: wallThickness * 3,\n       tags: [\n         getNextAdjacentEdge(rectangleSegmentA003),\n         getNextAdjacentEdge(rectangleSegmentB003),\n         getNextAdjacentEdge(rectangleSegmentC003),\n         getNextAdjacentEdge(rectangleSegmentD003)\n       ]\n     }, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'flange-with-patterns' file, and how does it achieve the creation of a flange with mounting holes and specific dimensions?"}, {"role": "assistant", "content": "// Flange\n// A flange is a flat rim, collar, or rib, typically forged or cast, that is used to strengthen an object, guide it, or attach it to another object. Flanges are known for their use in various applications, including piping, plumbing, and mechanical engineering, among others.\n\n// Define constants\nmountingHoleDia = .625 \nbaseDia = 4.625 \npipeDia = 1.25 \nthickness = .625 \ntotalThickness = 0.813 \ntopTotalDiameter = 2.313 \nbottomThickness = 0.06 \nbottomTotalDiameter = 2.5 \nmountingHolePlacementDiameter = 3.5 \nbaseThickness = .625 \ntopTotalThickness = totalThickness - (bottomThickness+baseThickness) \nholeLocator = baseDia - 8\nnHoles = 4\n\n// Add assertion so nHoles are always greater than 1\nassertGreaterThan(nHoles, 1, \"nHoles must be greater than 1\")\n\n// Create the circular pattern for the mounting holes\ncircles = startSketchOn('XY')\n  |> circle({center: [mountingHolePlacementDiameter /2, 0], radius: mountingHoleDia / 2}, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: nHoles,\n       rotateDuplicates: true\n     }, %)\n\n// Create the base of the flange and add the mounting holes\nflangeBase = startSketchOn('XY')\n  |> circle({center: [0, 0], radius: baseDia/2}, %)\n  |> hole(circles, %)\n  |> hole(circle({center: [0, 0], radius: pipeDia/2}, %), %)\n  |> extrude(baseThickness, %)\n\n// Plane for top face\ntopFacePlane = {\n  plane: {\n    origin: {\n      x: 0,\n      y: 0,\n      z: baseThickness\n    },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 1, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n// Create the extrusion on the top of the flange base\ntopExtrusion = startSketchOn(topFacePlane)\n  |> circle({center: [0, 0], radius: topTotalDiameter/2}, %)\n  |> hole(circle({center: [0, 0], radius: pipeDia/2}, %), %)\n  |> extrude(topTotalThickness, %)\n\n// Create the extrusion on the bottom of the flange base\nbottomExtrusion = startSketchOn(\"XY\")\n  |> circle({center: [0, 0], radius: bottomTotalDiameter/2}, %)\n  |> hole(circle({center: [0, 0], radius: pipeDia/2}, %), %)\n  |> extrude(-bottomThickness, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'flange-xy' file, and how does it create a flange with specific dimensions and mounting holes?"}, {"role": "assistant", "content": "// Flange with XY coordinates\n// A flange is a flat rim, collar, or rib, typically forged or cast, that is used to strengthen an object, guide it, or attach it to another object. Flanges are known for their use in various applications, including piping, plumbing, and mechanical engineering, among others.\n\n\n// Define constants in inches (in)\nmountingHoleDia = .625\nbaseDia = 4.625\npipeDia = 1.25\nthickness = .625\ntotalThickness = 0.813\ntopTotalDiameter = 2.313\nbottomThickness = 0.06\nbottomTotalDiameter = 2.5\nmountingHolePlacementDiameter = 3.5\nbaseThickness = .625\ntopTotalThickness = totalThickness - (bottomThickness + baseThickness)\nholeLocator = baseDia - 8\nnHoles = 4\n\n// Add assertion so nHoles are always greater than 1\nassertGreaterThan(nHoles, 1, \"nHoles must be greater than 1\")\n\n// Create the flange base and the six mounting holes\nflangeBase = startSketchOn('XY')\n  |> circle({ center: [0, 0], radius: baseDia / 2 }, %)\n  |> hole(circle({\n       center: [mountingHolePlacementDiameter / 2, 0],\n       radius: mountingHoleDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [0, mountingHolePlacementDiameter / 2],\n       radius: mountingHoleDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [-mountingHolePlacementDiameter / 2, 0],\n       radius: mountingHoleDia / 2\n     }, %), %)\n  |> hole(circle({\n       center: [0, -mountingHolePlacementDiameter / 2],\n       radius: mountingHoleDia / 2\n     }, %), %)\n  |> hole(circle({ center: [0, 0], radius: pipeDia / 2 }, %), %)\n  |> extrude(baseThickness, %)\n\n// Plane for top face\ntopFacePlane = {\n  plane: {\n    origin: { x: 0, y: 0, z: baseThickness },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 1, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n// Create the extrusion on the top of the flange base\ntopExtrusion = startSketchOn(topFacePlane, 'end')\n  |> circle({\n       center: [0, 0],\n       radius: topTotalDiameter / 2\n     }, %)\n  |> hole(circle({ center: [0, 0], radius: pipeDia / 2 }, %), %)\n  |> extrude(topTotalThickness, %)\n\n// Create the extrusion on the bottom of the flange base\nbottomExtrusion = startSketchOn(\"XY\")\n  |> circle({\n       center: [0, 0],\n       radius: bottomTotalDiameter / 2\n     }, %)\n  |> hole(circle({ center: [0, 0], radius: pipeDia / 2 }, %), %)\n  |> extrude(-bottomThickness, %)\n\n// https://www.mcmaster.com/44685K193/"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'focusrite-scarlett-mounting-bracket' file, and how does it achieve the design of a mounting bracket for the Focusrite Scarlett Solo audio interface?"}, {"role": "assistant", "content": "// A mounting bracket for the Focusrite Scarlett Solo audio interface\n// This is a bracket that holds an audio device underneath a desk or shelf. The audio device has dimensions of 144mm wide, 80mm length and 45mm depth with fillets of 6mm. This mounting bracket is designed to be 3D printed with PLA material\n\n// define constants in mm\nradius = 6.0\nwidth = 144.0\nlength = 80.0\ndepth = 45.0\nthk = 4\nholeDiam = 5\ntabLength = 25\ntabWidth = 12\ntabThk = 4\n\n// define a rectangular shape func\nfn rectShape = (pos, w, l) => {\n  rr = startSketchOn('xy')\n    |> startProfileAt([pos[0] - (w / 2), pos[1] - (l / 2)], %)\n    |> lineTo([pos[0] + w / 2, pos[1] - (l / 2)], %, $edge01)\n    |> lineTo([pos[0] + w / 2, pos[1] + l / 2], %, $edge02)\n    |> lineTo([pos[0] - (w / 2), pos[1] + l / 2], %, $edge03)\n    |> close(%, $edge04)\n  return rr\n}\n\n// define the bracket plane\nbracketPlane = {\n  plane: {\n    origin: { x: 0, y: length / 2 + thk, z: 0 },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 0, y: -1, z: 0 }\n  }\n}\n\n// build the bracket sketch around the body\nfn bracketSketch = (w, d, t) => {\n  s = startSketchOn(bracketPlane)\n    |> startProfileAt([-w / 2 - t, d + t], %)\n    |> lineTo([-w / 2 - t, -t], %, $edge1)\n    |> lineTo([w / 2 + t, -t], %, $edge2)\n    |> lineTo([w / 2 + t, d + t], %, $edge3)\n    |> lineTo([w / 2, d + t], %, $edge4)\n    |> lineTo([w / 2, 0], %, $edge5)\n    |> lineTo([-w / 2, 0], %, $edge6)\n    |> lineTo([-w / 2, d + t], %, $edge7)\n    |> close(%, $edge8)\n  return s\n}\n\n// build the body of the bracket\nbs = bracketSketch(width, depth, thk)\nbracketBody = bs\n  |> extrude(length + 2 * thk, %)\n  |> fillet({\n       radius: radius,\n       tags: [\n         getPreviousAdjacentEdge(bs.tags.edge7),\n         getPreviousAdjacentEdge(bs.tags.edge2),\n         getPreviousAdjacentEdge(bs.tags.edge3),\n         getPreviousAdjacentEdge(bs.tags.edge6)\n       ]\n     }, %)\n\n// define the tab plane\ntabPlane = {\n  plane: {\n    origin: { x: 0, y: 0, z: depth + thk },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 1, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n// build the tabs of the mounting bracket (right side)\ntabsR = startSketchOn(tabPlane)\n  |> startProfileAt([width / 2 + thk, length / 2 + thk], %)\n  |> line([tabWidth, -tabLength / 3], %, $edge11)\n  |> line([0, -tabLength / 3 * 2], %, $edge12)\n  |> line([-tabWidth, -tabLength / 3], %, $edge13)\n  |> close(%, $edge14)\n  |> hole(circle({\n       center: [\n         width / 2 + thk + tabWidth / 2,\n         length / 2 + thk - (tabLength / (3 / 2))\n       ],\n       radius: holeDiam / 2\n     }, %), %)\n  |> extrude(-tabThk, %)\n  |> fillet({\n       radius: holeDiam / 2,\n       tags: [\n         getNextAdjacentEdge(edge11),\n         getNextAdjacentEdge(edge12)\n       ]\n     }, %)\n  |> patternLinear3d({\n       axis: [0, -1, 0],\n       instances: 2,\n       distance: length + 2 * thk - (tabLength * 4 / 3)\n     }, %)\n\n// build the tabs of the mounting bracket (left side)\ntabsL = startSketchOn(tabPlane)\n  |> startProfileAt([-width / 2 - thk, length / 2 + thk], %)\n  |> line([-tabWidth, -tabLength / 3], %, $edge21)\n  |> line([0, -tabLength / 3 * 2], %, $edge22)\n  |> line([tabWidth, -tabLength / 3], %, $edge23)\n  |> close(%, $edge24)\n  |> hole(circle({\n       center: [\n         -width / 2 - thk - (tabWidth / 2),\n         length / 2 + thk - (tabLength / (3 / 2))\n       ], radius: holeDiam / 2\n     }, %), %)\n  |> extrude(-tabThk, %)\n  |> fillet({\n       radius: holeDiam / 2,\n       tags: [\n         getNextAdjacentEdge(edge21),\n         getNextAdjacentEdge(edge22)\n       ]\n     }, %)\n  |> patternLinear3d({\n       axis: [0, -1, 0],\n       instances: 2,\n       distance: length + 2 * thk - (tabLength * 4 / 3)\n     }, %)\n\n// define a plane for retention bumps\nretPlane = {\n  plane: {\n    origin: { x: -width / 2 + 20, y: 0, z: 0 },\n    xAxis: { x: 0, y: 1, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 1, y: 0, z: 0 }\n  }\n}\n\n// build the retention bump in the front\nretFront = startSketchOn(retPlane)\n  |> startProfileAt([-length / 2 - thk, 0], %)\n  |> line([0, thk], %)\n  |> line([thk, -thk], %)\n  |> close(%)\n  |> extrude(width - 40, %)\n\n// build the retention bump in the back\nretBack = startSketchOn(retPlane)\n  |> startProfileAt([length / 2 + thk, 0], %)\n  |> line([0, thk], %)\n  |> line([-thk, 0], %)\n  |> line([0, -thk], %)\n  |> close(%)\n  |> extrude(width - 40, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'food-service-spatula' file, and how does it achieve the design of a spatula with specific features such as slots and a grip?"}, {"role": "assistant", "content": "// Food Service Spatula\n// Use these spatulas for mixing, flipping, and scraping.\n\n// Define constants in millimeters (mm)\nflipperThickness = 3.5\nflipperLength = 70.0\nhandleWidth = 15.0\ngripLength = 150.0\nflipperFilletRadius = 5.0\nflipperSlotWidth = 10.0\ngripWidth = 10.0\ngripHeight = 20.0\ngripFilletRadius = 3.0\ngripSlotWidth = 8.0\n\n// function for drawing slots on a sketch given the start and end points as well as a width\nfn slot = (sketch1, start, end, width) => {\n  angle = if start[0] == end[0] {\n    if end[1] > start[1] {\n      90\n    } else {\n      270\n    }\n  } else {\n    if end[0] < start[0] {\n      toDegrees(atan((end[1] - start[1]) / (end[0] - start[0]))) + 180\n    } else {\n      toDegrees(atan((end[1] - start[1]) / (end[0] - start[0])))\n    }\n  }\n  dist = sqrt(pow(end[1] - start[1], 2) + pow(end[0] - start[0], 2))\n  xstart = width / 2 * cos(toRadians(angle - 90)) + start[0]\n  ystart = width / 2 * sin(toRadians(angle - 90)) + start[1]\n  slotSketch = startProfileAt([xstart, ystart], sketch1)\n    |> angledLine({ angle: angle, length: dist }, %, $line000)\n    |> tangentialArc({ radius: width / 2, offset: 180 }, %, $arc000)\n    |> angledLine({ angle: angle, length: -dist }, %, $line001)\n    |> tangentialArcTo([profileStartX(%), profileStartY(%)], %, $arc001)\n    |> close(%)\n  return slotSketch\n}\n\n// create a sketch on the \"XY\" plane\nsketch000 = startSketchOn('XY')\n\n// create a profile of the flipper\nflipperProfile = startProfileAt([-flipperLength, -32.000000], sketch000)\n  |> line([flipperLength, 2.000000], %)\n  |> yLine(60.000000, %, $backEdge)\n  |> line([-flipperLength, 2.000000], %)\n  |> arc({\n       angleEnd: 196.912390,\n       angleStart: 163.087610,\n       radius: 110.000000\n     }, %)\n  |> close(%)\n\n// create a profile of the middle\nslotProfile000 = slot(sketch000, [-25, 0], [-55, 0], flipperSlotWidth)\n\n// create a profile of the top slot\nslotProfile001 = slot(sketch000, [-25, 18], [-55, 19], flipperSlotWidth)\n\n// create a profile of the bottom slot\nslotProfile002 = slot(sketch000, [-25, -18], [-55, -19], flipperSlotWidth)\n\n// create a profile with slots for the spatula\nspatulaProfile = flipperProfile\n  |> hole(slotProfile000, %)\n  |> hole(slotProfile001, %)\n  |> hole(slotProfile002, %)\n\n// extrude the profile to create the spatula flipper\nflipper = extrude(flipperThickness, [spatulaProfile])\n\n// fillet the edges of the flipper\nfillet({\n  radius: flipperFilletRadius,\n  tags: [\n    getNextAdjacentEdge(backEdge),\n    getPreviousAdjacentEdge(backEdge)\n  ]\n}, flipper)\n\n// create a sketch on the \"XZ\" plane offset by half the thickness\nsketch001 = startSketchOn(offsetPlane(\"XZ\", -handleWidth / 2))\n\n// create a profile of the spatula handle\nhandleProfile = startProfileAt([0.000000, flipperThickness], sketch001)\n  |> line([31.819805, 31.819805], %, $handleBottomEdge)\n  |> line([140.953893, 51.303021], %)\n  |> line([-1.710101, 4.698463], %)\n  |> line([-141.995517, -51.682142], %, $handleTopEdge)\n  |> line([-36.139148, -36.139148], %)\n  |> xLine(7.071068, %)\n  |> close(%)\n\n// create an extrusion extrude001\nhandle = extrude(handleWidth, [handleProfile])\n\n// fillet the bend of the spatula handle\nfillet({\n  radius: 4,\n  tags: [\n    getNextAdjacentEdge(handleBottomEdge),\n    getNextAdjacentEdge(handleTopEdge)\n  ]\n}, handle)\n\n// define a plane which is at the end of the handle\nhandlePlane = {\n  plane: {\n    origin: [208.593833, 0.000000, 75.921946],\n    xAxis: [0.342020, -0.000000, -0.939693],\n    yAxis: [0.000000, 1.000000, 0.000000],\n    zAxis: [0.939693, -0.000000, 0.342020]\n  }\n}\n\n// create a sketch on the handle plane\nsketch002 = startSketchOn(handlePlane)\n\n// create a profile of the grip\ngripProfile = startProfileAt([-26.806746, -10.000000], sketch002)\n  |> xLine(gripWidth - 2 * gripFilletRadius, %)\n  |> arc({\n       angleStart: -90.000000,\n       angleEnd: 0.000000,\n       radius: gripFilletRadius\n     }, %)\n  |> yLine(gripHeight - 2 * gripFilletRadius, %)\n  |> arc({\n       angleStart: 0.000000,\n       angleEnd: 90.000000,\n       radius: gripFilletRadius\n     }, %)\n  |> xLine(-(gripWidth - 2 * gripFilletRadius), %)\n  |> arc({\n       angleStart: 90.000000,\n       angleEnd: 180.000000,\n       radius: gripFilletRadius\n     }, %)\n  |> yLine(-(gripHeight - 2 * gripFilletRadius), %, $gripEdgeTop)\n  |> arc({\n       angleStart: 180.000000,\n       angleEnd: 270.000000,\n       radius: gripFilletRadius\n     }, %)\n  |> close(%)\n\n// extrude the grip profile to create the grip\ngrip = extrude(-gripLength, [gripProfile])\n\n// create a sketch on the grip for the hole\nsketch003 = startSketchOn(grip, gripEdgeTop)\n\n// create a profile for the grip hole\ngripHoleProfile = slot(sketch003, [0, 200], [0, 210], gripSlotWidth)\n\n// cut a hole in the grip\nextrude(-gripWidth, gripHoleProfile)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'french-press' file, and how does it achieve the design of a French press coffee maker?"}, {"role": "assistant", "content": "// French Press\n// A french press immersion coffee maker\n\n\ncarafeDiameter = 4.41\ncarafeHeight = 7.32\nhandleThickness = 0.65\n\n// Upper ring of the metal structure\nsketch001 = startSketchOn('XZ')\n  |> startProfileAt([carafeDiameter / 2, 5.7], %)\n  |> angledLine([0, 0.1], %, $rectangleSegmentA001)\n  |> angledLine([\n       segAng(rectangleSegmentA001) - 90,\n       -0.75\n     ], %, $rectangleSegmentB001)\n  |> angledLine([\n       segAng(rectangleSegmentA001),\n       -segLen(rectangleSegmentA001)\n     ], %, $rectangleSegmentC001)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ angle: 360, axis: 'Y' }, %)\n\n// Create an angled plane to sketch the supports\nplane001 = {\n  plane: {\n    origin: [-0.26, 0.26, 0.0],\n    xAxis: [1, 1, 0.0],\n    yAxis: [0.0, 0.0, 1.0],\n    zAxis: [1.0, 0.0, 0.0]\n  }\n}\n\n// Cross section of the metal supports\nsketch002 = startSketchOn(plane001)\n  |> startProfileAt([carafeDiameter / 2, 5.7], %)\n  |> xLine(0.1, %)\n  |> yLine(-5.2, %, $edge1)\n  |> arc({\n       angleStart: 180,\n       angleEnd: 205,\n       radius: 0.3\n     }, %)\n  |> angledLine({ angle: -60, length: 0.6 }, %, $edge2)\n  |> arc({\n       angleStart: 30,\n       angleEnd: -120,\n       radius: 0.6\n     }, %)\n  |> angledLineToY({ angle: 150, to: -0.2 }, %, $edge3)\n  |> arc({\n       angleStart: 60,\n       angleEnd: 90,\n       radius: 0.5\n     }, %)\n  |> xLineTo(0.1, %, $edgeLen)\n  |> yLine(0.1, %)\n  |> xLine(segLen(edgeLen) + 0.035, %, $edge4)\n  |> arc({\n       angleStart: 90,\n       angleEnd: 60,\n       radius: 0.6\n     }, %)\n  |> angledLine({\n       angle: 150,\n       length: -segLen(edge3) + 0.035\n     }, %, $edge5)\n  |> arc({\n       angleStart: -120,\n       angleEnd: 30,\n       radius: 0.5\n     }, %)\n  |> angledLine({\n       angle: -60,\n       length: -segLen(edge2) + 0.035\n     }, %, $edge6)\n  |> arc({\n       angleStart: 205,\n       angleEnd: 180,\n       radius: 0.6\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> extrude(0.75, %)\n  |> patternCircular3d({\n       axis: [0, 0, 1],\n       center: [0, 0, 0],\n       instances: 4,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\n// Cross plate\nsketch003 = startSketchOn(offsetPlane('XY', 1))\n  |> circle({\n       center: [0, 0],\n       radius: carafeDiameter / 2 - 0.15\n     }, %)\n\nextrude001 = extrude(0.050, sketch003)\n\nsketch004 = startSketchOn(extrude001, 'END')\n  |> startProfileAt([0.3, 0.17], %)\n  |> yLine(1.2, %)\n  |> arc({\n       angleStart: 90,\n       angleEnd: -30,\n       radius: 1.2\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> patternCircular2d({\n       center: [0, 0],\n       instances: 3,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nextrude002 = extrude(-0.050, sketch004)\n\n// Filter screen\nsketch005 = startSketchOn('XZ')\n  |> startProfileAt([0.15, 1.11], %)\n  |> xLineTo(carafeDiameter / 2 - 0.2, %)\n  |> angledLineToX({\n       angle: 30,\n       to: carafeDiameter / 2 - 0.07\n     }, %, $seg1)\n  |> angledLine({ angle: -60, length: 0.050 }, %)\n  |> angledLine({ angle: 30, length: -segLen(seg1) }, %)\n  |> xLineTo(0.15, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\n// Plunger and stem\nsketch006 = startSketchOn('XZ')\n  |> startProfileAt([0.1, 1], %)\n  |> line([0.1, 0], %)\n  |> angledLineToX({ angle: 10, to: 0.05 }, %)\n  |> yLine(10, %)\n  |> line([0.6, 0], %)\n  |> yLine(-.05, %)\n  |> tangentialArc({ radius: 0.6, offset: -90 }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\n// Spiral plate\nsketch007 = startSketchOn(offsetPlane('XY', 1.12))\n  |> circle({\n       center: [0, 0],\n       radius: carafeDiameter / 2 - 0.24\n     }, %)\n  |> hole(circle({ center: [0, 0], radius: .15 }, %), %)\n\nextrude003 = extrude(0.050, sketch007)\n\n// Pattern holes in the spiral plate\nsketch008 = startSketchOn(extrude003, 'END')\n  |> circle({ center: [1.4, 0], radius: .3 }, %)\n  |> patternCircular2d({\n       center: [0, 0],\n       instances: 8,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nextrude004 = extrude(-0.050, sketch008)\n\n// Pattern holes in the spiral plate\nsketch009 = startSketchOn(extrude003, 'END')\n  |> circle({ center: [0.6, 0], radius: .2 }, %)\n  |> patternCircular2d({\n       center: [0, 0],\n       instances: 4,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nextrude005 = extrude(-0.050, sketch009)\n\n// Extrude a glass carafe body\nsketch010 = startSketchOn(\"XY\")\n  |> circle({\n       center: [0, 0],\n       radius: carafeDiameter / 2\n     }, %)\n\n// Perform a shell operation to hollow the carafe body with the top face removed\nextrude006 = extrude(carafeHeight, sketch010)\n  |> shell({ faces: [\"end\"], thickness: .07 }, %)\n\n// Draw and revolve the lid\nsketch011 = startSketchOn('XZ')\n  |> startProfileAt([0.2, carafeHeight - 0.7], %)\n  |> xLine(carafeDiameter / 2 - 0.3, %)\n  |> yLine(0.7, %)\n  |> xLine(0.3, %)\n  |> yLine(0.4, %)\n  |> line([-0.02, 0.02], %)\n  |> bezierCurve({\n       to: [-carafeDiameter / 2 - 0.1, 1],\n       control1: [-0.3, 0],\n       control2: [carafeDiameter / 10, 1]\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\n// Draw and extrude handle\nsketch012 = startSketchOn(offsetPlane('XZ', handleThickness / 2))\n  |> startProfileAt([2.3, 6.4], %)\n  |> line([0.56, 0], %)\n  |> tangentialArcTo([4.1, 5.26], %)\n  |> tangentialArcTo([4.17, 1.6], %)\n  |> tangentialArcTo([3.13, 0.61], %)\n  |> line([-1.09, 0], %)\n  |> line([0, 0.43], %)\n  |> line([0.99, -0.02], %)\n  |> tangentialArcTo([3.63, 1.6], %)\n  |> tangentialArcTo([3.56, 5.15], %)\n  |> tangentialArcTo([2.72, 5.88], %)\n  |> line([-0.4, 0], %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\nextrude007 = extrude(-handleThickness, sketch012)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'gear' file, and how does it achieve the creation of a spur gear with specific features such as teeth, keyway, and bore hole?"}, {"role": "assistant", "content": "// Spur Gear\n// A rotating machine part having cut teeth or, in the case of a cogwheel, inserted teeth (called cogs), which mesh with another toothed part to transmit torque. Geared devices can change the speed, torque, and direction of a power source. The two elements that define a gear are its circular shape and the teeth that are integrated into its outer edge, which are designed to fit into the teeth of another gear.\n\n\n// Define constants\nnTeeth = 21\nmodule = 0.5\npitchDiameter = module * nTeeth\npressureAngle = 20\naddendum = module\ndeddendum = 1.25 * module\nbaseDiameter = pitchDiameter * cos(toRadians(pressureAngle))\ntipDiameter = pitchDiameter + 2 * module\ngearHeight = 3\n\n// Interpolate points along the involute curve\ncmo = int(101)\nrs = map([0..cmo], (i) => {\n  return baseDiameter / 2 + i / cmo * (tipDiameter - baseDiameter) / 2\n})\n\n// Calculate operating pressure angle\nas = map(rs, (r) => {\n  return toDegrees(acos(baseDiameter / 2 / r))\n})\n\n// Calculate the involute function\ninvas = map(as, (a) => {\n  return tan(toRadians(a)) - toRadians(a)\n})\n\n// Map the involute curve\nxs = map([0..cmo], (i) => {\n  return rs[i] * cos(invas[i])\n})\n\nys = map([0..cmo], (i) => {\n  return rs[i] * sin(invas[i])\n})\n\n// Extrude the gear body\nbody = startSketchOn('XY')\n  |> circle({\n       center: [0, 0],\n       radius: baseDiameter / 2\n     }, %)\n  |> extrude(gearHeight, %)\n\ntoothAngle = 360 / nTeeth / 1.5\n\n// Plot the involute curve\nfn leftInvolute = (i, sg) => {\n  j = int(100 - i) // iterate backwards\n  return lineTo([xs[j], ys[j]], sg)\n}\n\nfn rightInvolute = (i, sg) => {\n  x = rs[i] * cos(toRadians(-toothAngle + toDegrees(atan(ys[i] / xs[i]))))\n  y = -rs[i] * sin(toRadians(-toothAngle + toDegrees(atan(ys[i] / xs[i]))))\n  return lineTo([x, y], sg)\n}\n\n// Draw gear teeth\nstart = startSketchOn('XY')\n  |> startProfileAt([xs[101], ys[101]], %)\nteeth = reduce([0..100], start, leftInvolute)\n  |> arc({\n       angleStart: 0,\n       angleEnd: toothAngle,\n       radius: baseDiameter / 2\n     }, %)\n  |> reduce([1..101], %, rightInvolute)\n  |> close(%)\n  |> extrude(gearHeight, %)\n  |> patternCircular3d({\n       axis: [0, 0, 1],\n       center: [0, 0, 0],\n       instances: nTeeth,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\n// Define the constants of the keyway and the bore hole\nkeywayWidth = 0.250\nkeywayDepth = keywayWidth / 2\nholeDiam = 2\nholeRadius = 1\nstartAngle = asin(keywayWidth / 2 / holeRadius)\n\n// Sketch the keyway and center hole and extrude\nkeyWay = startSketchOn(body, 'END')\n  |> startProfileAt([\n       holeRadius * cos(startAngle),\n       holeRadius * sin(startAngle)\n     ], %)\n  |> xLine(keywayDepth, %)\n  |> yLine(-keywayWidth, %)\n  |> xLine(-keywayDepth, %)\n  |> arc({\n       angleEnd: 180,\n       angleStart: -1 * 180 / pi() * startAngle + 360,\n       radius: holeRadius\n     }, %)\n  |> arc({\n       angleEnd: 180 / pi() * startAngle,\n       angleStart: 180,\n       radius: holeRadius\n     }, %)\n  |> close(%)\n  |> extrude(-gearHeight, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'gear-rack' file, and how does it achieve the creation of a 100mm gear rack with teeth designed to mesh with a pinion gear?"}, {"role": "assistant", "content": "// 100mm Gear Rack\n// A flat bar or rail that is engraved with teeth along its length. These teeth are designed to mesh with the teeth of a gear, known as a pinion. When the pinion, a small cylindrical gear, rotates, its teeth engage with the teeth on the rack, causing the rack to move linearly. Conversely, linear motion applied to the rack will cause the pinion to rotate.\n\n// Define constants\nlength = 100 \npitchHeight = 11.5 \nwidth = 5 \nheight = 12 \nminHeight = 10.875 \n\n// Create the body of the rack\nrackBody = startSketchOn('XY')\n  |> startProfileAt([-length / 2, 0], %)\n  |> line([length, 0], %)\n  |> line([0, minHeight], %)\n  |> line([-length, 0], %)\n  |> close(%)\n  |> extrude(width, %)\n\n// Create a function for sketch of a single tooth\nfn tooth = () => {\n  toothSketch = startSketchOn('XY')\n  |> startProfileAt([-length / 2 + 0.567672, minHeight], %)\n  |> tangentialArcToRelative([0.157636, 0.110378], %)\n  |> line([0.329118, 0.904244], %)\n  |> tangentialArcToRelative([0.157636, 0.110378], %)\n  |> line([0.186505, 0], %)\n  |> tangentialArcToRelative([0.157636, -0.110378], %)\n  |> line([0.329118, -0.904244], %)\n  |> tangentialArcToRelative([0.157636, -0.110378], %)\n  |> close(%)\n  |> extrude(width, %)\n  return toothSketch\n}\n\n// Pattern the single tooth over the length of the rack body\nteeth = tooth()\n  |> patternLinear3d({\n       axis: [10, 0, 0],\n       distance: 1.570796,\n       instances: 63\n     }, %)\n\n// Sketch and extrude the first end cap. This is a partial tooth\nendCapTooth = startSketchOn('XY')\n  |> startProfileAt([-length / 2, 11.849525], %)\n  |> line([0.314524, -0.864147], %)\n  |> tangentialArcToRelative([0.157636, -0.110378], %)\n  |> lineTo([-length / 2, minHeight], %)\n  |> close(%)\n  |> extrude(width, %)\n\n//Sketch and extrude the second end cap. This is a partial tooth\nendCapTooth2 = startSketchOn('XY')\n  |> startProfileAt([length / 2, 11.849525], %)\n  |> line([-0.314524, -0.864147], %)\n  |> tangentialArcToRelative([-0.157636, -0.110378], %)\n  |> lineTo([length / 2, minHeight], %)\n  |> close(%)\n  |> extrude(width, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code for the 'hex-nut', and how does it achieve the creation of a hex nut with specified dimensions?"}, {"role": "assistant", "content": "// Hex nut\n// A hex nut is a type of fastener with a threaded hole and a hexagonal outer shape, used in a wide variety of applications to secure parts together. The hexagonal shape allows for a greater torque to be applied with wrenches or tools, making it one of the most common nut types in hardware.\n\n\n// Define constants (5/16\" - 24 thread size)\nwallToWallLength = 0.5 \nthickness = 0.266 \ndiameter = 0.3125 \n\n\n// Define a function for the hex nut\nfn hexNut = (start, thk, innerDia) => {\n  hexNutSketch = startSketchOn('-XZ')\n    |> startProfileAt([start[0] + innerDia, start[1]], %)\n    |> angledLine({ angle: 240, length: innerDia }, %)\n    |> angledLine({ angle: 180, length: innerDia }, %)\n    |> angledLine({ angle: 120, length: innerDia }, %)\n    |> angledLine({ angle: 60, length: innerDia }, %)\n    |> angledLine({ angle: 0, length: innerDia * .90 }, %)\n    |> close(%)\n    |> hole(circle({\n         center: [start[0], start[1]],\n         radius: innerDia / 2\n       }, %), %)\n    |> extrude(thk, %)\n  return hexNutSketch\n}\n\n// Create a hex nut\nhexNut([0, 0], thickness, diameter)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the `pixelBox` function in the KCL code for the 'kitt' file, and how does it contribute to the overall design of the KittyCAD mascot?"}, {"role": "assistant", "content": "// Kitt\n// The beloved KittyCAD mascot in a voxelized style.\n\n// pixel box function\nfn pixelBox = (kitExtrude, extrudeTag, positionY, positionZ, width, height, depth) => {\n  pixelBoxBody = startSketchOn(kitExtrude, extrudeTag)\n    |> startProfileAt([positionY, positionZ], %)\n    |> line([0, height], %)\n    |> line([width, 0], %)\n    |> line([0, -height], %)\n    |> lineTo([profileStartX(%), profileStartY(%)], %)\n    |> close(%)\n    |> extrude(depth, %)\n  return pixelBoxBody\n}\n\n// 1. Kitty Body\nkitBodyElevation = 6\nkitBodyWidth = 26\nkitBodyHeight = 25\nkitBodyDepth = 18\n\nkitBody = startSketchOn('XZ')\n  |> startProfileAt([-kitBodyWidth / 2, kitBodyElevation], %)\n  |> line([0, kitBodyHeight], %)\n  |> line([kitBodyWidth, 0], %, $seg01)\n  |> line([0, -kitBodyHeight], %, $seg02)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> extrude(kitBodyDepth, %)\n\n// 2. Kitty Head (Frame of display)\nkitHeadOffset = 1\nkitHeadHeight = 16\n\nkitHeadElevation = kitBodyElevation + kitBodyHeight - kitHeadOffset - kitHeadHeight\n\n\nkitHeadWidth = kitBodyWidth - (kitHeadOffset * 2)\nkitHeadDepth = 3\nkitHead = pixelBox(kitBody, 'END', -kitHeadWidth / 2, kitHeadElevation, kitHeadWidth, kitHeadHeight, kitHeadDepth)\nkitFaceElevation = kitHeadElevation + 2\n\n// 3. Kitty Face\nkitFaceWidth = kitHeadWidth - 4\nkitFaceHeight = kitHeadElevation + kitHeadHeight - kitFaceElevation - 3\nkitFaceDepth = 2\n\nkitFace = startSketchOn(kitHead, 'END')\n  |> startProfileAt([-kitFaceWidth / 2, kitFaceElevation], %)\n  |> line([0, 1], %) // left lower corner up\n  |> line([-1, 0], %) // left lower corner left\n  |> line([0, kitFaceHeight], %) // left side up\n  |> line([1, 0], %) // left upper corner right\n  |> line([0, 1], %) // left upper corner up\n  |> line([kitFaceWidth, 0], %) // upper side right\n  |> line([0, -1], %) // right upper corner down\n  |> line([1, 0], %) // right upper corner right\n  |> line([0, -kitFaceHeight], %) // right side down\n  |> line([-1, 0], %) // right lower corner left\n  |> line([0, -1], %) // right lower corner down\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> extrude(-kitFaceDepth, %)\n\n// Kitty Face Features:\n// 3.1 Kitty Eyes\n\n// 3.1.1 Kitty Left Eye\nkitEyeDepth = 0.5\nkitEyeHeihgt = kitFaceElevation + 7\nkitEyeOffset = 7\n\n// 3.1.2 Kitty Right Eye\nkitLeftEye1 = pixelBox(kitFace, 'START', -kitEyeOffset, kitEyeHeihgt, 1, 1, kitEyeDepth)\n\n// 3.2 Kitty Nose\nkitLeftEye2 = pixelBox(kitFace, 'START', -kitEyeOffset + 1, kitEyeHeihgt + 1, 3, 1, kitEyeDepth)\nkitLeftEye3 = pixelBox(kitFace, 'START', -kitEyeOffset + 4, kitEyeHeihgt, 1, 1, kitEyeDepth)\nkitRightEye = pixelBox(kitFace, 'START', kitEyeOffset - 3, kitEyeHeihgt - 1, 2, 4, kitEyeDepth)\nkitNoseElevation = kitEyeHeihgt - 5\nkitNose = startSketchOn(kitFace, 'START')\n  |> startProfileAt([-2, kitNoseElevation], %) // H V\n  |> line([0, 1], %) // lower-left up\n  |> line([2, 0], %) // lower-left right\n  |> line([0, 2], %) // mid-left up\n  |> line([-1, 0], %) // upper-left left\n  |> line([0, 1], %) // upper-left up\n  |> line([3, 0], %) // upper-mid right\n  |> line([0, -1], %) // upper-right down\n  |> line([-1, 0], %) // upper-right left\n  |> line([0, -2], %) // mid-left down\n  |> line([2, 0], %) // lower-right right\n  |> line([0, -1], %) // lower-right down\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> extrude(kitEyeDepth, %)\n\n// 3.3 Kitty Mouth\nkitMouthOffset = 4\nkitMouthHeight = kitEyeHeihgt - 3\nkitMouthUpLeft = pixelBox(kitFace, 'START', -kitMouthOffset, kitMouthHeight, 1, 1, kitEyeDepth)\n\n// 4. Kitty Belly\nkitMouthDownLeft = pixelBox(kitFace, 'START', -kitMouthOffset + 1, kitMouthHeight - 1, 1, 1, kitEyeDepth)\nkitMouthUpRight = pixelBox(kitFace, 'START', kitMouthOffset, kitMouthHeight, 1, 1, kitEyeDepth)\nkitMouthDownRight = pixelBox(kitFace, 'START', kitMouthOffset - 1, kitMouthHeight - 1, 1, 1, kitEyeDepth)\nkitBellyElevation = kitBodyElevation + 1\n\nkitBellyHeight = kitHeadElevation - kitBellyElevation - 1\n\n// 4.1 Kitty VHS\nkitBellyWidth = kitHeadWidth\nkitBellyDepth = kitHeadDepth\nkitBelly = pixelBox(kitBody, 'END', -kitBellyWidth / 2, kitBellyElevation, kitBellyWidth, kitBellyHeight, kitBellyDepth)\nkitVHSelevation = kitBellyElevation + 1\n\nkitVHSheight = 2\n\n// 4.2 Kitty Floppy\nkitVHSwidth = 8\nkitVHSdepth = 1\nkitVHS = pixelBox(kitBelly, 'END', -kitVHSwidth / 2, kitVHSelevation, kitVHSwidth, kitVHSheight, kitVHSdepth)\nkitFloppyElevation = kitBellyElevation + 1\nkitFloppyHeight = 1\n\nkitFloppyWidth = 5\nkitFloppyOffset = kitBellyWidth / 2 - 1\nkitFloppyDepth = 2\n\n// 4.3 Kitty Belly Button\nkitFloppy1 = pixelBox(kitBelly, 'END', -kitFloppyOffset, kitFloppyElevation, kitFloppyWidth, kitFloppyHeight, -kitFloppyDepth)\nkitFloppy2 = pixelBox(kitBelly, 'END', -kitFloppyOffset, kitFloppyElevation + 2, kitFloppyWidth, kitFloppyHeight, -kitFloppyDepth)\nkitFloppy3 = pixelBox(kitBelly, 'END', kitFloppyOffset, kitFloppyElevation, -kitFloppyWidth, kitFloppyHeight, -kitFloppyDepth)\nkitBellyButtonOffset = kitHeadWidth / 2 - 3\nkitBellyButtonElevation = kitHeadElevation - 1\n\nkitBellyButtonWidth = 2\n\n// 4.4 Kitty Buttons\nkitBellyButtonHeight = 1\nkitBellyButtonDepth = kitHeadDepth + 1\nkitBellyButton = pixelBox(kitBody, 'END', -kitBellyButtonOffset, kitBellyButtonElevation, kitBellyButtonWidth, kitBellyButtonHeight, kitBellyButtonDepth)\n\nkitButtonWidth = 1\nkitButtonHeight = 2\nkitButtonDepth = kitFloppyDepth\nkitButtonElevation = kitFloppyElevation + 2\n\nkitButton1 = pixelBox(kitBelly, 'END', kitFloppyOffset, kitFloppyElevation + 2, -kitButtonWidth, kitButtonHeight, -kitButtonDepth)\n\n// 5. Kitty Legs\nkitButton2 = pixelBox(kitBelly, 'END', kitFloppyOffset - kitButtonWidth - 1, kitFloppyElevation + 2, -kitButtonWidth, kitButtonHeight, -kitButtonDepth)\nkitButton3 = pixelBox(kitBelly, 'END', kitFloppyOffset - (2 * (kitButtonWidth + 1)), kitFloppyElevation + 2, -kitButtonWidth, kitButtonHeight, -kitButtonDepth)\n\nkitShoeWidth = 7\nkitShoeLength = 10\nkitShoeHeight = 3\n\nfn kitLeg = (offsetFront, offsetSide) => {\n  kitShoeOffsetFront = (kitShoeLength / 2) - (kitBodyDepth / 2) - offsetFront\n\n  kitFootPrint = startSketchOn('XY')\n    |> startProfileAt([offsetSide, kitShoeOffsetFront], %)\n    |> line([kitShoeWidth, 0], %)\n    |> line([0, -kitShoeLength], %)\n    |> line([-kitShoeWidth, 0], %)\n    |> lineTo([profileStartX(%), profileStartY(%)], %)\n    |> close(%)\n\n  kitShoe = extrude(kitShoeHeight, kitFootPrint)\n\n  kitPantsOffsetSide = offsetSide + 1\n  kitPantsOffsetFront = 2 * kitShoeOffsetFront - 2\n  kitPantsWidth = kitShoeWidth - 2\n  kitPantsFrontWidth = kitPantsWidth\n  kitPantsHeight = kitBodyElevation - kitShoeHeight\n\n  kitPants = pixelBox(kitShoe, 'END', kitPantsOffsetSide, kitPantsOffsetFront, kitPantsFrontWidth, kitPantsWidth, kitPantsHeight)\n\n  return kitShoe\n}\nkitLegOffset = 3\n\nkitRightLeg = kitLeg(0, kitLegOffset)\nkitLeftLeg = kitLeg(0, -kitLegOffset - kitShoeWidth)\n\n// 6. Kitty Ears\nkitEarWidth = 8\nkitEarDepth = 8\nkitEarHeight = 2\n\nfn kitEar = (earOffsetFront, earOffsetSide) => {\n  kitNewEarOffsetFront = kitBodyDepth - earOffsetFront\n  kitNewEarOffsetSide = -(kitBodyWidth / 2 - earOffsetSide)\n  baseVolume = pixelBox(kitBody, seg01, kitNewEarOffsetSide, kitNewEarOffsetFront, kitEarWidth, -kitEarDepth, kitEarHeight)\n\n  secondOffset = 1\n  \n  secondLevel = pixelBox(baseVolume, 'END', kitNewEarOffsetSide + secondOffset, kitNewEarOffsetFront - 0.01, kitEarWidth - (secondOffset * 2), -kitEarDepth + secondOffset * 2, kitEarHeight)\n\n  thirdOffset = 2\n  thirdLevel = pixelBox(secondLevel, 'END', kitNewEarOffsetSide + thirdOffset, kitNewEarOffsetFront - 0.02, kitEarWidth - (thirdOffset * 2), -kitEarDepth + thirdOffset * 2, kitEarHeight)\n\n  fourthOffset = 3\n  fourthLevel = pixelBox(thirdLevel, 'END', kitNewEarOffsetSide + fourthOffset, kitNewEarOffsetFront - 0.03, kitEarWidth - (fourthOffset * 2), -kitEarDepth + fourthOffset * 2, kitEarHeight)\n\n  return baseVolume\n}\nkitEarOffsetFront = 4\nkitEarOffsetSide = 1\n\nkitRightEar = kitEar(kitEarOffsetFront, kitEarOffsetSide)\nkitLeftEar = kitEar(kitEarOffsetFront, kitBodyWidth - kitEarWidth - kitEarOffsetSide)\n\n// 7. Kitty Side\n// 7.1 Grill\ngrillOffset = 4\n\ngrillRowA = kitBodyElevation + kitBodyHeight - grillOffset\ngrillRowB = grillRowA - 2\ngrillRowC = grillRowA - 4\n\ngrillColumnA = kitBodyDepth - grillOffset\ngrillColumnB = grillColumnA - 1\ngrillColumnC = grillColumnA - 2\ngrillColumnD = grillColumnA - 3\ngrillColumnE = grillColumnA - 4\n\ngrillHoleSize = 1\ngrillHoleDepth = -2\n\ngrillHoleAB = pixelBox(kitBody, seg02, grillRowA, grillColumnB, grillHoleSize, grillHoleSize, grillHoleDepth)\n\ngrillHoleAD = pixelBox(kitBody, seg02, grillRowA, grillColumnD, grillHoleSize, grillHoleSize, grillHoleDepth)\n\ngrillHoleBA = pixelBox(kitBody, seg02, grillRowB, grillColumnA, grillHoleSize, grillHoleSize, grillHoleDepth)\n\ngrillHoleBC = pixelBox(kitBody, seg02, grillRowB, grillColumnC, grillHoleSize, grillHoleSize, grillHoleDepth)\n\ngrillHoleBE = pixelBox(kitBody, seg02, grillRowB, grillColumnE, grillHoleSize, grillHoleSize, grillHoleDepth)\n\ngrillHoleCB = pixelBox(kitBody, seg02, grillRowC, grillColumnB, grillHoleSize, grillHoleSize, grillHoleDepth)\n\ngrillHoleCD = pixelBox(kitBody, seg02, grillRowC, grillColumnD, grillHoleSize, grillHoleSize, grillHoleDepth)\n\n// 7.2 Kitty Vent\nkitVentElevation = kitBodyElevation + 1\nkitVentOffset = 1\nkitVentHoleWidth = 1\nkitVentHoleHeight = 4\nkitVentHoleDepth = grillHoleDepth\n\nkitVentA = pixelBox(kitBody, seg02, kitVentElevation, kitVentOffset, kitVentHoleHeight, kitVentHoleWidth, kitVentHoleDepth)\n\nkitVentB = pixelBox(kitBody, seg02, kitVentElevation, kitVentOffset + 2, kitVentHoleHeight, kitVentHoleWidth, kitVentHoleDepth)\n\nkitVentC = pixelBox(kitBody, seg02, kitVentElevation, kitVentOffset + 4, kitVentHoleHeight, kitVentHoleWidth, kitVentHoleDepth)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'lego' file, and how does it achieve the creation of a standard Lego brick with specific dimensions and features?"}, {"role": "assistant", "content": "// Lego Brick\n// A standard Lego brick. This is a small, plastic construction block toy that can be interlocked with other blocks to build various structures, models, and figures. There are a lot of hacks used in this code.\n\n\n// Define constants\nlbumps = 5 // number of bumps long\nwbumps = 3 // number of bumps wide\npitch = 8.0\nclearance = 0.1\nbumpDiam = 4.8\nbumpHeight = 1.8\nheight = 3.2\nt = (pitch - (2 * clearance) - bumpDiam) / 2.0\npostDiam = pitch - t // works out to 6.5\ntotalLength = lbumps * pitch - (2.0 * clearance)\ntotalWidth = wbumps * pitch - (2.0 * clearance)\n\n// Calculate the number of segments in the length and width\nlSegments = totalLength / lbumps\nwSegments = totalWidth / wbumps\n\n// Add assertions to ensure that the number of bumps are greater than 1\nassertGreaterThan(lbumps, 1, \"lbumps must be greater than 1\")\nassertGreaterThan(wbumps, 1, \"wbumps must be greater than 1\")\n\n// Create the plane for the pegs. This is a hack so that the pegs can be patterned along the face of the lego base.\npegFace = {\n  plane: {\n    origin: { x: 0, y: 0, z: height },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 1, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n// Create the plane for the tubes underneath the lego. This is a hack so that the tubes can be patterned underneath the lego.\ntubeFace = {\n  plane: {\n    origin: { x: 0, y: 0, z: height - t },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 1, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n// Make the base\ns = startSketchOn('XY')\n  |> startProfileAt([-totalWidth / 2, -totalLength / 2], %)\n  |> line([totalWidth, 0], %)\n  |> line([0, totalLength], %)\n  |> line([-totalWidth, 0], %)\n  |> close(%)\n  |> extrude(height, %)\n\n// Sketch and extrude a rectangular shape to create the shell underneath the lego. This is a hack until we have a shell function.\nshellExtrude = startSketchOn(s, \"start\")\n  |> startProfileAt([\n       -(totalWidth / 2 - t),\n       -(totalLength / 2 - t)\n     ], %)\n  |> line([totalWidth - (2 * t), 0], %)\n  |> line([0, totalLength - (2 * t)], %)\n  |> line([-(totalWidth - (2 * t)), 0], %)\n  |> close(%)\n  |> extrude(-(height - t), %)\n\n// Create the pegs on the top of the base\npeg = startSketchOn(s, 'end')\n  |> circle({\n       center: [\n         -(pitch * (wbumps - 1) / 2),\n         -(pitch * (lbumps - 1) / 2)\n       ],\n       radius: bumpDiam / 2\n     }, %)\n  |> patternLinear2d({\n       axis: [1, 0],\n       instances: wbumps,\n       distance: pitch\n     }, %)\n  |> patternLinear2d({\n       axis: [0, 1],\n       instances: lbumps,\n       distance: pitch\n     }, %)\n  |> extrude(bumpHeight, %)\n\n// Create the pegs on the bottom of the base\ntubePattern = startSketchOn(tubeFace)\n  |> circle({\n       center: [\n         -(pitch * (wbumps - 1) / 2 - (pitch / 2)),\n         -(pitch * (lbumps - 1) / 2 - (pitch / 2))\n       ],\n       radius: bumpDiam / 2\n     }, %)\n  |> patternLinear2d({\n       axis: [1, 0],\n       instances: wbumps - 1,\n       distance: pitch\n     }, %)\n  |> patternLinear2d({\n       axis: [0, 1],\n       instances: lbumps - 1,\n       distance: pitch\n     }, %)\n  |> extrude(-bumpHeight, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'lug-nut' file, and how does it achieve the creation of a lug nut model?"}, {"role": "assistant", "content": "// Lug Nut\n// lug Nuts are essential components used to create secure connections, whether for electrical purposes, like terminating wires or grounding, or for mechanical purposes, such as providing mounting points or reinforcing structural joints. \n\n// Define the plane the lug lives on\n\n\n// Define constants\nlugDiameter = 24 \nlugHeadLength = lugDiameter * .5 \nlugThreadDiameter = lugDiameter/2 * .85 \nlugLength = 30 \nlugThreadDepth = lugLength - 12.7 \n\ncustomPlane = {\n      plane: {\n        origin: { x: 0, y: 0, z: 0 },\n        xAxis: { x: 1, y: 0, z: 0 },\n        yAxis: { x: 0, y: 1, z: 0 },\n        zAxis: { x: 0, y: 0, z: 1 }\n      }\n    }\n\nfn lug = (plane, length, diameter) => {\n\n    lugSketch = startSketchOn(customPlane)\n      |> startProfileAt([0 + diameter/2, 0], %)\n      |> angledLineOfYLength({\n        angle: 70,\n        length: lugHeadLength,\n      }, %)\n      |> xLineTo(lugDiameter/2, %)\n      |> yLineTo(lugLength, %)\n      |> tangentialArc({\n        offset: 90,\n        radius: 3,\n      }, %)\n      |> xLineTo(0+.001, %, $c1)\n      |> yLineTo(lugThreadDepth, %)\n      |> xLineTo(lugThreadDiameter, %)\n      |> yLineTo(0, %)\n      |> close(%)\n      |> revolve({\n        axis: \"Y\",\n      }, %)\n    return lugSketch\n}\n\nlug(customPlane, lugLength, lugDiameter)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'mounting-plate' file, and how does it create the mounting plate with specific features such as holes and fillets?"}, {"role": "assistant", "content": "// Mounting Plate\n// A flat piece of material, often metal or plastic, that serves as a support or base for attaching, securing, or mounting various types of equipment, devices, or components.\n\n\n// Define constants\nplateLength = 10\nplateWidth = 6\nfilletRadius = 0.5\nplateThickness = .5\ncenterHoleDiameter = 2\n\n// Create a function that defines the body width and length of the mounting plate. Tag the corners so they can be passed through the fillet function.\nfn rectShape = (pos, w, l) => {\n  rr = startSketchOn('XY')\n    |> startProfileAt([pos[0] - (w / 2), pos[1] - (l / 2)], %)\n    |> lineTo([pos[0] + w / 2, pos[1] - (l / 2)], %, $edge1)\n    |> lineTo([pos[0] + w / 2, pos[1] + l / 2], %, $edge2)\n    |> lineTo([pos[0] - (w / 2), pos[1] + l / 2], %, $edge3)\n    |> close(%, $edge4)\n  return rr\n}\n\n// Define the hole radius and x, y location constants\nholeRadius = .25\nholeIndex = .75\n\n// Create the mounting plate extrusion, holes, and fillets\nrs = rectShape([0, 0], plateWidth, plateLength)\npart = rs\n  |> hole(circle({\n       center: [\n         -plateWidth / 2 + holeIndex,\n         plateLength / 2 - holeIndex\n       ],\n       radius: holeRadius\n     }, %), %)\n  |> hole(circle({\n       center: [\n         plateWidth / 2 - holeIndex,\n         plateLength / 2 - holeIndex\n       ],\n       radius: holeRadius\n     }, %), %)\n  |> hole(circle({\n       center: [\n         -plateWidth / 2 + holeIndex,\n         -plateLength / 2 + holeIndex\n       ],\n       radius: holeRadius\n     }, %), %)\n  |> hole(circle({\n       center: [\n         plateWidth / 2 - holeIndex,\n         -plateLength / 2 + holeIndex\n       ],\n       radius: holeRadius\n     }, %), %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: centerHoleDiameter\n     }, %), %)\n  |> extrude(plateThickness, %)\n  |> fillet({\n       radius: filletRadius,\n       tags: [\n         getPreviousAdjacentEdge(rs.tags.edge1),\n         getPreviousAdjacentEdge(rs.tags.edge2),\n         getPreviousAdjacentEdge(rs.tags.edge3),\n         getPreviousAdjacentEdge(rs.tags.edge4)\n       ]\n     }, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the primary function of the KCL code in the 'multi-axis-robot' file, and how does it achieve the construction of a 4-axis robotic arm for industrial applications?"}, {"role": "assistant", "content": "// Robot Arm\n// A 4 axis robotic arm for industrial use. These machines can be used for assembly, packaging, organization of goods, and quality inspection processes\n\n\naxisJ4 = 25\naxisJ3 = 60\naxisJ2 = 110\naxisJ1 = 80\n\n// Robot Arm Base\nbasePlateRadius = 5\nbasePlateThickness = 0.5\nbaseChamfer = 2\nbaseHeight = 5\n\nsketch001 = startSketchOn('XY')\n  |> startProfileAt([-basePlateRadius, -basePlateRadius], %)\n  |> angledLine([0, 2 * basePlateRadius], %, $rectangleSegmentA001)\n  |> angledLine([\n       segAng(rectangleSegmentA001) + 90,\n       2 * basePlateRadius\n     ], %, $rectangleSegmentB001)\n  |> angledLine([\n       segAng(rectangleSegmentA001),\n       -segLen(rectangleSegmentA001)\n     ], %, $rectangleSegmentC001)\n  |> lineTo([profileStartX(%), profileStartY(%)], %, $rectangleSegmentD001)\n  |> close(%)\nextrude001 = extrude(basePlateThickness, sketch001)\n  |> chamfer({\n       length: baseChamfer,\n       tags: [\n         getNextAdjacentEdge(rectangleSegmentA001),\n         getNextAdjacentEdge(rectangleSegmentB001),\n         getNextAdjacentEdge(rectangleSegmentC001),\n         getNextAdjacentEdge(rectangleSegmentD001)\n       ]\n     }, %)\n\n// Base Motor for actuating first joint\nsketch002 = startSketchOn(extrude001, 'END')\n  |> circle({ center: [0, 0], radius: 4 }, %, $referenceEdge)\nextrude002 = extrude(baseHeight - basePlateThickness - 1.5, sketch002)\n  |> fillet({\n       radius: 0.1,\n       tags: [getOppositeEdge(referenceEdge)]\n     }, %)\nsketch003 = startSketchOn(extrude002, 'END')\n  |> circle({ center: [0, 0], radius: 0.5 }, %)\nextrude003 = extrude(1, sketch003)\n\n// Pattern M8 mounting bolts in base\nsketch4A = startSketchOn(extrude001, 'END')\n  |> circle({\n       center: [\n         -basePlateRadius + 1,\n         -basePlateRadius + baseChamfer + 0.5\n       ],\n       radius: 0.4\n     }, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: 4,\n       rotateDuplicates: true\n     }, %)\n\nextrude4A = extrude(-basePlateThickness, sketch4A)\n\nsketch4B = startSketchOn(extrude001, 'END')\n  |> circle({\n       center: [\n         -basePlateRadius + 0.5 + baseChamfer,\n         -basePlateRadius + 1\n       ],\n       radius: 0.4\n     }, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: 4,\n       rotateDuplicates: true\n     }, %)\n\nextrude4B = extrude(-basePlateThickness, sketch4B)\n\n// Housing for J2 motor\n// Define Planes to change robot angle\nplane001 = {\n  plane: {\n    origin: [0.0, 0.0, baseHeight - 1.5 + 0.1],\n    xAxis: [1.0, 0.0, 0.0],\n    yAxis: [0.0, 1.0, 0.0],\n    zAxis: [0.0, 0.0, 1.0]\n  }\n}\nplane002 = {\n  plane: {\n    origin: [0.0, 0.0, 0.0],\n    xAxis: [\n      sin(toRadians(axisJ1)),\n      cos(toRadians(axisJ1)),\n      0.0\n    ],\n    yAxis: [0.0, 0.0, 1.0],\n    zAxis: [1.0, 0.0, 0.0]\n  }\n}\n\n// Create Rotating Base\nsketch005 = startSketchOn(plane001)\n  |> circle({ center: [0, 0], radius: 3.9 }, %, $referenceEdge1)\nextrude005 = extrude(1.5 - 0.1, sketch005)\n  |> fillet({\n       radius: 0.1,\n       tags: [getOppositeEdge(referenceEdge1)]\n     }, %)\n\nsketch006 = startSketchOn(plane002)\n  |> startProfileAt([3.5, baseHeight], %)\n  |> angledLine({ angle: 60, length: 1.75 }, %)\n  |> arc({\n       angleStart: -30,\n       angleEnd: -30 + 180,\n       radius: 3\n     }, %)\n  |> angledLineToY({ angle: 60, to: baseHeight }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\nextrude006 = extrude(1, sketch006)\n\nsketch007 = startSketchOn(extrude006, 'END')\n  |> circle({\n       center: [\n         1.75 * cos(toRadians(axisJ1)) / abs(cos(toRadians(axisJ1))),\n         8\n       ],\n       radius: 2.75\n     }, %, $referenceEdge2)\nextrude007 = extrude(1.5, sketch007)\n  |> fillet({\n       radius: 0.1,\n       tags: [getOppositeEdge(referenceEdge2)]\n     }, %)\n\n// Draw Bolt Pattern on Rotating Base\nsketch008 = startSketchOn(extrude007, 'END')\n  |> circle({\n       center: [\n         1.75 * cos(toRadians(axisJ1)) / abs(cos(toRadians(axisJ1))),\n         6.75\n       ],\n       radius: 0.2\n     }, %)\n  |> patternCircular2d({\n       center: [\n         1.75 * cos(toRadians(axisJ1)) / abs(cos(toRadians(axisJ1))),\n         8\n       ],\n       instances: 4,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\nextrude008 = extrude(0.2, sketch008)\n\nsketch009 = startSketchOn(extrude007, 'END')\n  |> circle({\n       center: [\n         1.75 * cos(toRadians(axisJ1)) / abs(cos(toRadians(axisJ1))),\n         8\n       ],\n       radius: 0.5\n     }, %, $referenceEdge3)\nextrude009 = extrude(0.15, sketch009)\n  |> fillet({\n       radius: 0.1,\n       tags: [getOppositeEdge(referenceEdge3)]\n     }, %)\n\nsketch010 = startSketchOn(plane002)\n  |> circle({ center: [1.75, 8], radius: 0.3 }, %)\nextrude010 = extrude(-1, sketch010)\n\n// J2 Axis for Robot Arm\n// Define Constants for J2 Axis Robot Arm\naxisJ2ArmLength = 31\naxisJ2ArmWidth = 4\naxisJ2ArmThickness = 2.5\n\n// Define Plane to Move J2 Axis Robot Arm\nplane003 = {\n  plane: {\n    origin: [-0.1, 0.0, 0.0],\n    xAxis: [\n      sin(toRadians(axisJ1)),\n      cos(toRadians(axisJ1)),\n      0.0\n    ],\n    yAxis: [0.0, 0.0, 1.0],\n    zAxis: [1.0, 0.0, 0.0]\n  }\n}\n\n// Create Body of J2 Robot Arm\nsketch011 = startSketchOn(plane003)\n  |> startProfileAt([\n       1.75 - (axisJ2ArmWidth / 2 * sin(toRadians(axisJ2))),\n       8 + axisJ2ArmWidth / 2 * cos(toRadians(axisJ2))\n     ], %)\n  |> arc({\n       angleStart: 90 + axisJ2,\n       angleEnd: 270 + axisJ2,\n       radius: axisJ2ArmWidth / 2\n     }, %)\n  |> angledLine({\n       angle: axisJ2,\n       length: axisJ2ArmLength\n     }, %)\n  |> arc({\n       angleStart: -90 + axisJ2,\n       angleEnd: 90 + axisJ2,\n       radius: axisJ2ArmWidth / 2\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\nextrude011 = extrude(-axisJ2ArmThickness, sketch011)\n\nsketch012 = startSketchOn(extrude011, 'START')\n  |> circle({ center: [-1.75, 8], radius: 1.9 }, %, $referenceEdge4)\n\nextrude012 = extrude(0.15, sketch012)\n  |> fillet({\n       radius: 0.1,\n       tags: [getOppositeEdge(referenceEdge4)]\n     }, %)\nsketch013 = startSketchOn(extrude011, 'START')\n  |> circle({\n       center: [\n         -1.75 - (axisJ2ArmLength * cos(toRadians(axisJ2))),\n         8 + axisJ2ArmLength * sin(toRadians(axisJ2))\n       ],\n       radius: 1.9\n     }, %, $referenceEdge5)\n\nextrude013 = extrude(1, sketch013)\n  |> fillet({\n       radius: 0.1,\n       tags: [getOppositeEdge(referenceEdge5)]\n     }, %)\n\n// Draw Bolt Patterns on J2 Robot Arm\nsketch014 = startSketchOn(extrude012, 'END')\n  |> circle({ center: [-1.75, 6.75], radius: 0.2 }, %)\n  |> patternCircular2d({\n       center: [-1.75, 8],\n       instances: 8,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nextrude014 = extrude(0.15, sketch014)\n\nsketch015 = startSketchOn(extrude013, 'END')\n  |> circle({\n       center: [\n         -1.75 - ((axisJ2ArmLength - 1) * cos(toRadians(axisJ2))),\n         8 + (axisJ2ArmLength - 1.5) * sin(toRadians(axisJ2))\n       ],\n       radius: 0.2\n     }, %)\n  |> patternCircular2d({\n       center: [\n         -1.75 - (axisJ2ArmLength * cos(toRadians(axisJ2))),\n         8 + axisJ2ArmLength * sin(toRadians(axisJ2))\n       ],\n       instances: 4,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nextrude015 = extrude(0.15, sketch015)\n\nsketch016 = startSketchOn(extrude011, 'END')\n  |> circle({\n       center: [\n         1.75 + axisJ2ArmLength * cos(toRadians(axisJ2)),\n         8 + axisJ2ArmLength * sin(toRadians(axisJ2))\n       ],\n       radius: 0.3\n     }, %)\n\nextrude016 = extrude(1, sketch016)\n\n// J3 Axis for Robot Arm\naxisJ3C = axisJ3 - 180 + axisJ2\naxisJ3CArmLength = 20\naxisJ3CArmWidth = 3.75\naxisJ3CArmThickness = 2.5\n\n// Create Body of J3 Robot Arm\nsketch017 = startSketchOn(plane002)\n  |> startProfileAt([\n       1.75 + axisJ2ArmLength * cos(toRadians(axisJ2)) - (axisJ3CArmWidth / 2 * sin(toRadians(axisJ3C))),\n       8 + axisJ2ArmLength * sin(toRadians(axisJ2)) + axisJ3CArmWidth / 2 * cos(toRadians(axisJ3C))\n     ], %)\n  |> arc({\n       angleStart: 90 + axisJ3C,\n       angleEnd: 270 + axisJ3C,\n       radius: axisJ3CArmWidth / 2\n     }, %)\n  |> angledLine({\n       angle: axisJ3C,\n       length: axisJ3CArmLength\n     }, %)\n  |> arc({\n       angleStart: 270 + axisJ3C,\n       angleEnd: 90 + axisJ3C,\n       radius: axisJ3CArmWidth / 2\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %, $seg01)\n  |> close(%)\nextrude017 = extrude(axisJ3CArmThickness, sketch017)\n\nsketch018 = startSketchOn(extrude017, 'END')\n  |> circle({\n       center: [\n         1.75 + axisJ2ArmLength * cos(toRadians(axisJ2)),\n         8 + axisJ2ArmLength * sin(toRadians(axisJ2))\n       ],\n       radius: 3.7 / 2\n     }, %, $referenceEdge6)\n\nextrude018 = extrude(0.15, sketch018)\n  |> fillet({\n       radius: 0.1,\n       tags: [getOppositeEdge(referenceEdge6)]\n     }, %)\n\n// Draw Bolt Pattern on J3 Robot Arm\nsketch019 = startSketchOn(extrude018, 'END')\n  |> circle({\n       center: [\n         1.75 + (axisJ2ArmLength - 1) * cos(toRadians(axisJ2)),\n         8 + (axisJ2ArmLength - 1.5) * sin(toRadians(axisJ2))\n       ],\n       radius: 0.2\n     }, %)\n  |> patternCircular2d({\n       center: [\n         1.75 + axisJ2ArmLength * cos(toRadians(axisJ2)),\n         8 + axisJ2ArmLength * sin(toRadians(axisJ2))\n       ],\n       instances: 8,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nextrude019 = extrude(0.15, sketch019)\n\n// On the J3 Robot Arm Body, Create Mounting Clevis for Grabber Claw\nsketch020 = startSketchOn(extrude017, 'START')\n  |> circle({\n       center: [\n         -1.75 - (axisJ2ArmLength * cos(toRadians(axisJ2))) - (axisJ3CArmLength * cos(toRadians(axisJ3C))),\n         8 + axisJ2ArmLength * sin(toRadians(axisJ2)) + axisJ3CArmLength * sin(toRadians(axisJ3C))\n       ],\n       radius: axisJ3CArmWidth / 2\n     }, %)\nextrude020 = extrude(-0.5, sketch020)\n\nsketch021 = startSketchOn(extrude017, 'END')\n  |> circle({\n       center: [\n         1.75 + axisJ2ArmLength * cos(toRadians(axisJ2)) + axisJ3CArmLength * cos(toRadians(axisJ3C)),\n         8 + axisJ2ArmLength * sin(toRadians(axisJ2)) + axisJ3CArmLength * sin(toRadians(axisJ3C))\n       ],\n       radius: axisJ3CArmWidth / 2.01\n     }, %)\n\nextrude021 = extrude(-0.5, sketch021)\n\n// Define Grabber Claw Constants\ngrabberLength = 7\n\nsketch022 = startSketchOn(extrude021, 'START')\n  |> circle({ center: [0, 0], radius: 0.10 }, %)\n\nextrude022 = extrude(-0.01, sketch022)\n\n// Build Upper Claw Finger\nsketch023 = startSketchOn(extrude022, 'START')\n  |> startProfileAt([\n       1.75 + axisJ2ArmLength * cos(toRadians(axisJ2)) + axisJ3CArmLength * cos(toRadians(axisJ3C)),\n       8 + axisJ2ArmLength * sin(toRadians(axisJ2)) + axisJ3CArmLength * sin(toRadians(axisJ3C))\n     ], %)\n  |> angledLine({\n       angle: axisJ3C + axisJ4 / 2,\n       length: grabberLength / 4\n     }, %)\n  |> arc({\n       angleStart: 150 + axisJ3C + axisJ4 / 2,\n       angleEnd: 30 + axisJ3C + axisJ4 / 2,\n       radius: grabberLength / 3\n     }, %)\n  |> angledLine({\n       angle: axisJ3C + axisJ4 / 2,\n       length: grabberLength / 6\n     }, %)\n  |> angledLine({\n       angle: axisJ3C + axisJ4 / 2 + 132,\n       length: grabberLength / 3.5\n     }, %)\n  |> angledLine({\n       angle: axisJ3C + axisJ4 / 2 + 160,\n       length: grabberLength / 3.5\n     }, %)\n  |> angledLine({\n       angle: axisJ3C + axisJ4 / 2 + 200,\n       length: grabberLength / 3\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n\nextrude023 = extrude(-1.5, sketch023)\n\n// Build Lower Claw Finger\nsketch024 = startSketchOn(extrude022, 'START')\n  |> startProfileAt([\n       1.75 + axisJ2ArmLength * cos(toRadians(axisJ2)) + axisJ3CArmLength * cos(toRadians(axisJ3C)),\n       8 + axisJ2ArmLength * sin(toRadians(axisJ2)) + axisJ3CArmLength * sin(toRadians(axisJ3C))\n     ], %)\n  |> angledLine({\n       angle: axisJ3C - (axisJ4 / 2),\n       length: grabberLength / 4\n     }, %)\n  |> arc({\n       angleStart: 210 + axisJ3C - (axisJ4 / 2),\n       angleEnd: 330 + axisJ3C - (axisJ4 / 2),\n       radius: grabberLength / 3\n     }, %)\n  |> angledLine({\n       angle: axisJ3C - (axisJ4 / 2),\n       length: grabberLength / 6\n     }, %)\n  |> angledLine({\n       angle: axisJ3C - (axisJ4 / 2) - 132,\n       length: grabberLength / 3.5\n     }, %)\n  |> angledLine({\n       angle: axisJ3C - (axisJ4 / 2) - 160,\n       length: grabberLength / 3.5\n     }, %)\n  |> angledLine({\n       angle: axisJ3C - (axisJ4 / 2) - 200,\n       length: grabberLength / 3\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\nextrude024 = extrude(-1.5, sketch024)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'pipe' file, and how does it achieve the creation of a tubular section with varying diameters?"}, {"role": "assistant", "content": "// Pipe\n// A tubular section or hollow cylinder, usually but not necessarily of circular cross-section, used mainly to convey substances that can flow.\n\n// Define constants\npipeTotalLength = 20\npipeLargeDiaLength = 1\npipeLargeDia = 1\npipeSmallDia = .75\nthickness = 0.125\npipeTransitionAngle = 60\npipeTransitionLength = 0.5\npipeSmallDiaLength = pipeTotalLength-pipeTransitionLength- pipeLargeDiaLength\n\n// Create the sketch to be revolved around the y-axis. Use the small diameter, large diameter, length, and thickness to define the sketch.\npipeSketch = startSketchOn('XY')\n  |> startProfileAt([pipeSmallDia - (thickness / 2), 38], %)\n  |> line([thickness, 0], %)\n  |> line([0, -(pipeSmallDiaLength)], %)\n  |> angledLineOfYLength({\n    angle: -60,\n    length: pipeTransitionLength,\n  }, %)\n  |> line([0, -pipeLargeDiaLength], %)\n  |> xLine(-thickness, %)\n  |> line([0, pipeLargeDiaLength], %)\n  |> angledLineToX({\n    angle: -pipeTransitionAngle+180,\n    to: pipeSmallDia - thickness/2,\n  }, %)\n  |> close(%)\n\n// Revolve the sketch to create the pipe\npipe = revolve({ axis: 'y' }, pipeSketch)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'pipe-flange-assembly' file, and how does it achieve the creation of a pipe and flange assembly?"}, {"role": "assistant", "content": "// Pipe and Flange Assembly\n// A crucial component in various piping systems, designed to facilitate the connection, disconnection, and access to piping for inspection, cleaning, and modifications. This assembly combines pipes (long cylindrical conduits) with flanges (plate-like fittings) to create a secure yet detachable joint.\n\n\nflangeThickness = .125\nflangeBaseDia = 2\nboreHeight = 1\nflangePipeDia = 1\nmountingHoleDia = 0.425\nscrewDia = 0.375\ntol = 0.010\nhexNutScale = 0.90\nwallThickness = 0.5\nscrewLength = 1.125\nwasherThickness = 0.0625\nscrewStart = [\n  0,\n  flangeThickness + washerThickness,\n  1.375\n]\ncapRatio = .190 / .313 // Ratio grabbed from another screw\nhexRatio = 5 / 32 / .190 // Ratio grabbed from another screw\nhexStartingAngle = 210 // first angle of hex pattern (degrees)\nhexInteriorAngle = 120 // degrees\nhexChangeAngle = 180 - hexInteriorAngle // degrees\n\n\nscrewPlane = {\n  plane: {\n    origin: {\n      x: screwStart[0],\n      y: screwStart[1],\n      z: screwStart[2]\n    },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 0, y: 1, z: 0 }\n  }\n}\n\nfn capScrew = (start, length, dia) => {\n  headLength = dia // inch\n  wallToWallLength = hexRatio * dia\n  headDia = dia / capRatio\n  hexWallLength = wallToWallLength / 2 * 1 / cos(toRadians(30)) // inch\n\n\n  // Length of Cap Head is always equal to diameter\n  capHeadLength = dia\n\n  // Create the head of the cap screw\n  screwHeadSketch = startSketchOn(screwPlane)\n    |> circle({ center: [0, 0], radius: headDia / 2 }, %)\n\n  // Extrude the screw head sketch\n  screwHead = extrude(dia, screwHeadSketch)\n\n  // Define the sketch of the hex pattern on the screw head\n  hexPatternSketch = startSketchOn(screwHead, 'end')\n    |> startProfileAt([\n         -start[0] + wallToWallLength / 2,\n         start[2]\n       ], %)\n    |> yLine(-hexWallLength / 2, %)\n    |> angledLine({\n         angle: hexStartingAngle,\n         length: hexWallLength\n       }, %)\n    |> angledLine({\n         angle: hexStartingAngle - hexChangeAngle,\n         length: hexWallLength\n       }, %)\n    |> angledLine({\n         angle: hexStartingAngle - (2 * hexChangeAngle),\n         length: hexWallLength\n       }, %)\n    |> angledLine({\n         angle: hexStartingAngle - (3 * hexChangeAngle),\n         length: hexWallLength\n       }, %)\n    |> angledLine({\n         angle: hexStartingAngle - (4 * hexChangeAngle),\n         length: hexWallLength\n       }, %)\n    |> close(%)\n  hexPattern = extrude(-headLength * 0.75, hexPatternSketch)\n\n  return hexPattern\n}\n\nworkingPlane = {\n  plane: {\n    origin: { x: 0, y: flangeThickness, z: 0 },\n    xAxis: { x: 0, y: 0, z: 1 },\n    yAxis: { x: 1, y: 0, z: 0 },\n    zAxis: { x: 0, y: 1, z: 0 }\n  }\n}\n\n// Washer function\nfn washer = (plane, start, thk, innerDia, outerDia) => {\n  washerSketch = startSketchOn(plane)\n    |> circle({\n         center: [start[0], start[1]],\n         radius: outerDia / 2\n       }, %)\n    |> hole(circle({\n         center: [start[0], start[1]],\n         radius: innerDia / 2\n       }, %), %)\n    |> extrude(thk, %)\n  return washerSketch\n}\n\n// Hex nut function\nfn hexNut = (start, thk, innerDia) => {\n  hexNutSketch = startSketchOn({\n         plane: {\n           origin: {\n             x: start[0],\n             y: -wallThickness - washerThickness,\n             z: start[2]\n           },\n           xAxis: { x: 1, y: 0, z: 0 },\n           yAxis: { x: 0, y: 0, z: 1 },\n           zAxis: { x: 0, y: 1, z: 0 }\n         }\n       })\n    |> startProfileAt([0 + innerDia * hexNutScale, 0], %)\n    |> angledLine({\n         angle: 240,\n         length: innerDia * hexNutScale\n       }, %)\n    |> angledLine({\n         angle: 180,\n         length: innerDia * hexNutScale\n       }, %)\n    |> angledLine({\n         angle: 120,\n         length: innerDia * hexNutScale\n       }, %)\n    |> angledLine({\n         angle: 60,\n         length: innerDia * hexNutScale\n       }, %)\n    |> angledLine({ angle: 0, length: innerDia * .90 }, %)\n    |> close(%)\n    |> hole(circle({ center: [0, 0], radius: innerDia / 2 }, %), %)\n    |> extrude(-thk, %)\n  return hexNutSketch\n}\n\n// Mounting holes pattern\nmountingHolePattern = startSketchOn('XZ')\n  |> circle({\n       center: [screwStart[0], screwStart[2]],\n       radius: screwDia / 2 + tol\n     }, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: 7,\n       rotateDuplicates: true\n     }, %)\n\n// Sketch and revolve the pipe\npipe = startSketchOn('XY')\n  |> startProfileAt([flangePipeDia / 2 - tol, 0], %)\n  |> line([0, -2], %)\n  |> angledLine({ angle: -60, length: .5 }, %)\n  |> line([0, -1], %)\n  |> line([-flangeThickness, 0], %)\n  |> line([0, 1], %)\n  |> angledLine({ angle: -240, length: .5 }, %)\n  |> line([0, 5], %)\n  |> angledLine({ angle: 60, length: .5 }, %)\n  |> line([0, 1], %)\n  |> line([flangeThickness, 0], %)\n  |> line([0, -1], %)\n  |> angledLine({ angle: 240, length: .5 }, %)\n  |> close(%)\n  |> revolve({ axis: 'y' }, %)\n\n// Sketch and extrude the wall\nwall = startSketchOn('XZ')\n  |> startProfileAt([-4, -4], %)\n  |> line([0, 8], %)\n  |> line([8, 0], %)\n  |> line([0, -8], %)\n  |> close(%)\n  |> hole(mountingHolePattern, %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: flangePipeDia / 2\n     }, %), %)\n  |> extrude(wallThickness, %)\n\n// Sketch and revolve the flange\nflangeBase = startSketchOn('XZ')\n  |> circle({\n       center: [0, 0],\n       radius: flangeBaseDia\n     }, %)\n  |> hole(mountingHolePattern, %)\n  |> hole(circle({\n       center: [0, 0],\n       radius: flangePipeDia / 2\n     }, %), %)\n  |> extrude(-flangeThickness, %)\n\n// Create the washer and pattern around the flange\nwasher(workingPlane, [screwStart[2], screwStart[0]], 0.0625, screwDia + tol, 0.625)\n  |> patternCircular3d({\n       axis: [0, 1, 0],\n       center: [0, 0, 0],\n       instances: 7,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\n// Create the cap screw and pattern around the flange\ncapScrew([\n       0,\n       flangeThickness + washerThickness,\n       1.375\n     ], screwLength, screwDia)\n  |> patternCircular3d({\n       axis: [0, 1, 0],\n       center: [0, 0, 0],\n       instances: 7,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nscrewBodySketch = startSketchOn(screwPlane)\n  |> circle({ center: [0, 0], radius: screwDia / 2 }, %)\nscrewBody = extrude(-screwLength, screwBodySketch)\n  |> patternCircular3d({\n       axis: [0, 1, 0],\n       center: [0, 0, 0],\n       instances: 7,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\n// Create a plane for the washers on the back side of the wall\nbackSideWasherPlane = {\n  plane: {\n    origin: {\n      x: 0,\n      y: -wallThickness - washerThickness,\n      z: 0\n    },\n    xAxis: { x: 0, y: 0, z: 1 },\n    yAxis: { x: 1, y: 0, z: 0 },\n    zAxis: { x: 0, y: 1, z: 0 }\n  }\n}\n\n// Create the washers on the backside of the wall\nwasher(backSideWasherPlane, [screwStart[2], screwStart[0]], 0.0625, screwDia + tol, 0.625)\n  |> patternCircular3d({\n       axis: [0, 1, 0],\n       center: [0, 0, 0],\n       instances: 7,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\n// Create the hex nut and pattern around the flange\nhexNut([\n       screwStart[0],\n       screwStart[1],\n       screwStart[2]\n     ], .25, screwDia + tol)\n  |> patternCircular3d({\n       axis: [0, 1, 0],\n       center: [0, 0, 0],\n       instances: 7,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'poopy-shoe' file, and how does it achieve the design of a poop chute for a Bambu Labs printer?"}, {"role": "assistant", "content": "// Poopy Shoe\n// poop shute for bambu labs printer - optimized for printing.\n\nwallThickness = 0.125 \nwallsWidth = 3 \nheight = 5.125 \nfilletRadius = 0.050 \nbackLength = 6 \nexitHeight = 1 \nfrontLength = 7 \n\nsketch001 = startSketchOn(\"-YZ\")\n  |> startProfileAt([wallsWidth / 2, 0], %)\n  |> xLine(wallThickness / 2, %)\n  |> angledLineToX({ angle: 60, to: wallsWidth }, %, $seg01)\n  |> yLineTo(height, %)\n  |> xLine(-wallThickness, %)\n  |> yLineTo(segEndY(seg01), %)\n  |> angledLineToX({\n       angle: 60,\n       to: wallsWidth / 2 + wallThickness / 2\n     }, %)\n  |> xLine(-wallThickness, %)\n  |> angledLineToX({ angle: 180 - 60, to: wallThickness }, %)\n  |> yLineTo(height, %)\n  |> xLineTo(0, %)\n  |> yLineTo(segEndY(seg01), %)\n  |> angledLineToY({ angle: 180 - 60, to: 0 }, %)\n  |> close(%)\npart001 = revolve({\n  angle: 90,\n  axis: {\n    custom: {\n      axis: [1.0, 0.0],\n      origin: [0.0, height + .0001]\n    }\n  }\n}, sketch001)\n\nsketch002 = startSketchOn('-YZ')\n  |> startProfileAt([wallsWidth / 2, 0], %)\n  |> xLine(wallThickness / 2, %)\n  |> angledLineToX({ angle: 60, to: wallsWidth }, %, $seg02)\n  |> yLineTo(height, %)\n  |> xLine(-wallThickness, %)\n  |> yLineTo(segEndY(seg01), %)\n  |> angledLineToX({\n       angle: 60,\n       to: wallsWidth / 2 + wallThickness / 2\n     }, %)\n  |> xLine(-wallThickness, %)\n  |> angledLineToX({ angle: 180 - 60, to: wallThickness }, %)\n  |> yLineTo(height, %)\n  |> xLineTo(0, %)\n  |> yLineTo(segEndY(seg02), %)\n  |> angledLineToY({ angle: 180 - 60, to: 0 }, %)\n  |> close(%)\n  |> extrude(backLength - height, %)\n\ncustomPlane = {\n  plane: {\n    origin: {\n      x: 0,\n      y: -(wallsWidth / 2 - (wallThickness / 2)),\n      z: 0\n    },\n    xAxis: { x: 1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 0, y: -1, z: 0 }\n  }\n}\nsketch003 = startSketchOn(customPlane)\n  |> startProfileAt([0, 0], %)\n  |> tangentialArc({ offset: 60, radius: height }, %)\n  |> angledLineToY({ angle: 60, to: 0 }, %)\n  |> close(%)\n  |> extrude(wallThickness, %)\n\nsketch004 = startSketchOn(sketch002, 'END')\n  |> startProfileAt([0, 0], %)\n  |> yLineTo(height, %)\n  |> xLineTo(wallThickness, %)\n  |> yLineTo(segEndY(seg01), %)\n  |> angledLineToX({\n       angle: 180 - 60,\n       to: wallsWidth / 2 - (wallThickness / 2)\n     }, %)\n  |> xLine(wallThickness, %)\n  |> angledLineToY({ angle: 60, to: segEndY(seg01) }, %)\n  |> yLineTo(height, %)\n  |> xLine(wallThickness, %)\n  |> tangentialArcTo([\n       (frontLength - wallsWidth) / 2 + wallsWidth,\n       height - ((height - exitHeight) / 2)\n     ], %)\n  |> tangentialArcTo([frontLength, exitHeight], %)\n  |> yLineTo(0, %)\n  |> close(%, $seg04)\n  |> extrude(wallThickness, %)\n\ncustomPlane2 = {\n  plane: {\n    origin: {\n      x: -1 * (backLength - height + wallsWidth),\n      y: 0,\n      z: 0\n    },\n    xAxis: { x: 0, y: -1, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 1, y: 0, z: 0 }\n  }\n}\nsketch005 = startSketchOn(customPlane2)\n  |> startProfileAt([0, 0], %)\n  |> yLineTo(height, %)\n  |> xLineTo(wallsWidth, %)\n  |> tangentialArcTo([\n       (frontLength - wallsWidth) / 2 + wallsWidth,\n       height - ((height - exitHeight) / 2)\n     ], %)\n  |> tangentialArcTo([frontLength, exitHeight], %)\n  |> yLineTo(0, %, $seg03)\n  |> close(%)\n  |> extrude(wallThickness, %)\n\nsketch006 = startSketchOn(sketch005, seg03)\n  |> startProfileAt([0, -1 * (backLength - height)], %)\n  |> xLineTo(-exitHeight, %)\n  |> yLine(-wallsWidth, %)\n  |> xLineTo(0, %)\n  |> close(%)\n  |> extrude(wallThickness, %)\n\nsketch007 = startSketchOn(sketch004, 'END')\n  |> startProfileAt([0, 0], %)\n  |> xLineTo(wallThickness, %)\n  |> yLineTo(height, %)\n  |> xLineTo(0, %)\n  |> close(%)\n  |> extrude(wallsWidth - (2 * wallThickness), %)\n\ncustomPlane3 = {\n  plane: {\n    origin: {\n      x: -1 * (backLength - height + wallsWidth),\n      y: 0,\n      z: wallThickness\n    },\n    xAxis: { x: 0, y: -1, z: 0 },\n    yAxis: { x: 1, y: 0, z: 0 },\n    zAxis: { x: 0, y: 0, z: 1 }\n  }\n}\n\n  sketch008 = startSketchOn(customPlane3)\n    |> startProfileAt([wallThickness, wallThickness], %)\n    |> xLineTo(frontLength, %)\n    |> yLine(wallsWidth-2*wallThickness, %)\n    |> xLineTo(wallThickness, %)\n    |> close(%)\n    |> extrude(-wallThickness, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'router-template-cross-bar' file, and how does it achieve the creation of a notch in a cross bar?"}, {"role": "assistant", "content": "// Router template for a cross bar\n// A guide for routing a notch into a cross bar.\n\nrouterDiameter = 12.7\nmmInInch = 25.4\ntemplateDiameter = mmInInch * 11 / 16\ntemplateGap = (templateDiameter - routerDiameter) / 2 - 0.5\nslateWidthHalf = 41.5 / 2\nminClampingDistance = 50 + 30\ntemplateThickness = 10\nradius = 10\ndepth = 30\ndistanceToInsideEdge = slateWidthHalf+templateThickness+templateGap\nsketch001 = startSketchOn('XZ')\n  |> startProfileAt([ZERO, depth + templateGap], %)\n  |> xLine(slateWidthHalf - radius, %, $seg01)\n  |> arc({\n       angleEnd: 0,\n       angleStart: 90,\n       radius: 10 + templateGap\n     }, %, $seg09)\n  |> yLineTo(-templateThickness, %, $seg03)\n  |> xLine(templateThickness, %, $seg07)\n  |> yLineTo((segEndY(seg01, %) + templateThickness) / 2 - templateThickness, %, $seg02)\n  |> xLineTo(segEndX(seg03) + minClampingDistance, %, $seg06)\n  |> yLine(templateThickness * 2, %, $seg08)\n  |> xLineTo(segEndX(seg02) + 0, %, $seg05)\n  |> yLineTo(segEndY(seg01) + templateThickness, %, $seg10)\n  |> xLineTo(ZERO, %, $seg04)\n  |> xLine(-segLen(seg04), %)\n  |> yLine(-segLen(seg10), %)\n  |> xLine(-segLen(seg05), %)\n  |> yLine(-segLen(seg08), %)\n  |> xLine(segLen(seg06), %)\n  |> yLine(-segLen(seg02), %)\n  |> xLine(segLen(seg07), %)\n  |> yLine(segLen(seg03), %)\n  |> arc({\n       angleEnd: 90,\n       angleStart: 180,\n       radius: 10 + templateGap\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\nextrude001 = extrude(5, sketch001)\n\nsketch003 = startSketchOn(extrude001, 'START')\n  |> startProfileAt([distanceToInsideEdge, 0], %)\n  |> angledLine([180, templateThickness], %, $rectangleSegmentA002)\n  |> angledLine([\n       segAng(rectangleSegmentA002) + 90,\n       templateThickness\n     ], %, $rectangleSegmentB002)\n  |> angledLine([\n       segAng(rectangleSegmentA002),\n       -segLen(rectangleSegmentA002)\n     ], %, $rectangleSegmentC002)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\nextrude003 = extrude(13, sketch003)\n\nsketch002 = startSketchOn(extrude001, 'START')\n  |> startProfileAt([-distanceToInsideEdge, 0], %)\n  |> angledLine([0, templateThickness], %, $rectangleSegmentA001)\n  |> angledLine([\n       segAng(rectangleSegmentA001) - 90,\n       templateThickness\n     ], %, $rectangleSegmentB001)\n  |> angledLine([\n       segAng(rectangleSegmentA001),\n       -segLen(rectangleSegmentA001)\n     ], %, $rectangleSegmentC001)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n\nextrude002 = extrude(13, sketch002)\n\nsketch004 = startSketchOn(extrude002, 'END')\n  |> startProfileAt([-distanceToInsideEdge, 0], %)\n  |> angledLine([0, distanceToInsideEdge*2], %, $rectangleSegmentA003)\n  |> angledLine([\n       segAng(rectangleSegmentA003) - 90,\n       templateThickness\n     ], %, $rectangleSegmentB003)\n  |> angledLine([\n       segAng(rectangleSegmentA003),\n       -segLen(rectangleSegmentA003)\n     ], %, $rectangleSegmentC003)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\nextrude004 = extrude(4, sketch004)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the 'router-template-slate' KCL code, and how does it achieve the creation of a router template for a slate?"}, {"role": "assistant", "content": "// Router template for a slate\n// A guide for routing a slate for a cross bar.\n\n// Define constants\nrouterDiameter = 12.7 \nmmInInch = 25.4 \ntemplateDiameter = mmInInch * 11 / 16 \ntemplateGap = ((templateDiameter - routerDiameter) / 2) -0.5 \nslateWidthHalf = 41.5 / 2 \nminClampingDistance = 50 + 30 \ntemplateThickness = 10 \nradius = 10 \ndepth = 30 \nlength001 = slateWidthHalf - radius \nlength002 = depth + minClampingDistance \n\n// Create the first sketch\nsketch001 = startSketchOn('XZ')\n  |> startProfileAt([0, depth - templateGap], %)\n  |> xLine(length001, %, $seg01)\n  |> arc({\n       angleEnd: 0,\n       angleStart: 90,\n       radius: radius - templateGap\n     }, %)\n  |> yLineTo(-templateGap * 2 - (templateDiameter / 2), %, $seg05)\n  |> xLineTo(slateWidthHalf + templateThickness, %, $seg04)\n  |> yLine(-length002, %, $seg03)\n  |> xLineTo(ZERO, %, $seg02)\n  // |> line([7.78, 11.16], %)\n  |> xLine(-segLen(seg02), %)\n  |> yLine(segLen(seg03), %)\n  |> xLine(segLen(seg04), %)\n  |> yLine(segLen(seg05), %)\n  |> arc({\n       angleEnd: 90,\n       angleStart: 180,\n       radius: radius - templateGap\n     }, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n\n// Extrude the first sketch\nextrude001 = extrude(5, sketch001)\n\n// Create the second sketch\nsketch002 = startSketchOn(extrude001, 'START')\n  |> startProfileAt([\n       -slateWidthHalf,\n       -templateGap * 2 - (templateDiameter / 2)\n     ], %)\n  |> xLine(-7, %, $rectangleSegmentA001)\n  |> angledLine([\n       segAng(rectangleSegmentA001) + 90,\n       minClampingDistance\n     ], %, $rectangleSegmentB001)\n  |> angledLine([\n       segAng(rectangleSegmentA001),\n       -segLen(rectangleSegmentA001)\n     ], %, $rectangleSegmentC001)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n\n// Extrude the second sketch\nextrude002 = extrude(7.5, sketch002)\n\n// Create the third sketch\nsketch003 = startSketchOn(extrude001, 'START')\n  |> startProfileAt([\n       slateWidthHalf,\n       -templateGap * 2 - (templateDiameter / 2)\n     ], %)\n  |> xLine(7, %, $rectangleSegmentA002)\n  |> angledLine([\n       segAng(rectangleSegmentA002) - 90,\n       minClampingDistance\n     ], %)\n  |> angledLine([\n       segAng(rectangleSegmentA002),\n       -segLen(rectangleSegmentA002)\n     ], %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n\n// Extrude the third Sketch\nextrude003 = extrude(7.5, sketch003)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'sheet-metal-bracket' file, and how does it achieve the creation of a sheet metal bracket component?"}, {"role": "assistant", "content": "// Sheet Metal Bracket\n// A component typically made from flat sheet metal through various manufacturing processes such as bending, punching, cutting, and forming. These brackets are used to support, attach, or mount other hardware components, often providing a structural or functional base for assembly.\n\n\n// Define constants such as sheet metal thickness, bend radius, flange length, bolt diameter size, etc.\nthickness = 0.090 \nbendRad = 0.08 \noutsideBendRad = bendRad + thickness \nflangeLength = 0.5 \nhatHeight = 3 \nhatWidth = 5 \nboltSize = 0.25 \nflangeWidth = 1.5 \n\n\n// Sketch and extrude the base shape and fillet the inside and outside edges.\nbaseExtrusion = startSketchOn('-XZ')\n  |> startProfileAt([0, 0], %)\n  |> line([0, thickness], %, $e1)\n  |> line([flangeLength, 0], %, $e2)\n  |> line([0, hatHeight], %, $e3)\n  |> line([hatWidth, 0], %, $e4)\n  |> line([0, -hatHeight], %, $e5)\n  |> line([flangeLength, 0], %, $e6)\n  |> line([0, -thickness], %, $e7)\n  |> line([-flangeLength - thickness, 0], %, $e8)\n  |> line([0, hatHeight], %, $e9)\n  |> line([-hatWidth + 2 * thickness, 0], %, $e10)\n  |> line([0, -hatHeight], %, $e11)\n  |> close(%, $e12)\n  |> extrude(hatWidth, %)\n  |> fillet({\n       radius: bendRad,\n       tags: [getNextAdjacentEdge(e2)]\n     }, %)\n  |> fillet({\n       radius: outsideBendRad,\n       tags: [getNextAdjacentEdge(e3)]\n     }, %)\n  |> fillet({\n       radius: outsideBendRad,\n       tags: [getNextAdjacentEdge(e4)]\n     }, %)\n  |> fillet({\n       radius: bendRad,\n       tags: [getNextAdjacentEdge(e5)]\n     }, %)\n  |> fillet({\n       radius: outsideBendRad,\n       tags: [getNextAdjacentEdge(e8)]\n     }, %)\n  |> fillet({\n       radius: bendRad,\n       tags: [getNextAdjacentEdge(e9)]\n     }, %)\n  |> fillet({\n       radius: bendRad,\n       tags: [getNextAdjacentEdge(e10)]\n     }, %)\n  |> fillet({\n       radius: outsideBendRad,\n       tags: [getNextAdjacentEdge(e11)]\n     }, %)\n\n// Define the flanges and place the bolt holes\nflange1 = startSketchOn('XY')\n  |> startProfileAt([0, 0], %)\n  |> line([0, hatWidth], %)\n  |> line([flangeWidth, 0], %, $e13)\n  |> line([0, -hatWidth], %, $e14)\n  |> close(%)\n  |> hole(circle({ center: [0.75, 1], radius: boltSize }, %), %)\n  |> hole(circle({ center: [0.75, 4], radius: boltSize }, %), %)\n  |> extrude(thickness, %)\n  |> fillet({\n       radius: 0.5,\n       tags: [\n         getNextAdjacentEdge(e13),\n         getNextAdjacentEdge(e14)\n       ]\n     }, %)\n\nflange2 = startSketchOn('XY')\n  |> startProfileAt([-6, 0], %)\n  |> line([0, hatWidth], %)\n  |> line([-flangeWidth, 0], %, $e15)\n  |> line([0, -hatWidth], %, $e16)\n  |> close(%)\n  |> hole(circle({ center: [-6.75, 1], radius: boltSize }, %), %)\n  |> hole(circle({ center: [-6.75, 4], radius: boltSize }, %), %)\n  |> extrude(thickness, %)\n  |> fillet({\n       radius: 0.25,\n       tags: [\n         getNextAdjacentEdge(e15),\n         getNextAdjacentEdge(e16)\n       ]\n     }, %)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code for the 'socket-head-cap-screw', and how does it achieve the creation of a 1.00-inch long #10-24 socket head cap screw?"}, {"role": "assistant", "content": "// Socket Head Cap Screw\n// This is for a #10-24 screw that is 1.00 inches long. A socket head cap screw is a type of fastener that is widely used in a variety of applications requiring a high strength fastening solution. It is characterized by its cylindrical head and internal hexagonal drive, which allows for tightening with an Allen wrench or hex key.\n\n\n// Define constants\nscrewLength = 1.000 \nscrewDiameter = .190 \nheadDiameter = .313 \nheadLength = screwDiameter \nhexWallToWall = 5 / 32 \ncapRatio = screwDiameter / headDiameter\nhexRatio = hexWallToWall / headDiameter\nhexWallLength = hexWallToWall / 2 * 1 / cos(toRadians(30)) \nhexStartingAngle = 210 // first angle of hex pattern\nhexInteriorAngle = 120 \nhexChangeAngle = 180 - hexInteriorAngle \n\n\n// Write a function that defines the Socket Head Cap Screw\nfn capScrew = (start, length, dia, capHeadLength) => {\n  // Create the head of the cap screw\n  screwHeadSketch = startSketchOn('XZ')\n    |> circle({\n         center: [start[0], start[1]],\n         radius: dia / capRatio / 2\n       }, %)\n\n  // Extrude the screw head sketch\n  screwHead = extrude(capHeadLength, screwHeadSketch)\n\n  // Define the sketch of the hex pattern on the screw head\n  hexPatternSketch = startSketchOn(screwHead, 'end')\n    |> startProfileAt([hexWallToWall / 2, 0], %)\n    |> yLine(-hexWallLength / 2, %)\n    |> angledLine({\n         angle: hexStartingAngle,\n         length: hexWallLength\n       }, %)\n    |> angledLine({\n         angle: hexStartingAngle - hexChangeAngle,\n         length: hexWallLength\n       }, %)\n    |> angledLine({\n         angle: hexStartingAngle - (2 * hexChangeAngle),\n         length: hexWallLength\n       }, %)\n    |> angledLine({\n         angle: hexStartingAngle - (3 * hexChangeAngle),\n         length: hexWallLength\n       }, %)\n    |> angledLine({\n         angle: hexStartingAngle - (4 * hexChangeAngle),\n         length: hexWallLength\n       }, %)\n    |> close(%)\n  hexPattern = extrude(-headLength * 0.75, hexPatternSketch)\n\n  screwBodySketch = startSketchOn(screwHead, \"start\")\n    |> circle({\n         center: [start[0], start[1]],\n         radius: dia / 2\n       }, %)\n  screwBody = extrude(length, screwBodySketch)\n  return screwBody\n}\n\ncapScrew([0, 0], screwLength, screwDiameter, screwDiameter)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'tire' file, and how does it achieve the creation of a tire model?"}, {"role": "assistant", "content": "// Tire\n// A tire is a critical component of a vehicle that provides the necessary traction and grip between the car and the road. It supports the vehicle's weight and absorbs shocks from road irregularities.\n\n\n// Define constants\ntireInnerDiameter = 482.6\ntireOuterDiameter = 660.4\ntireDepth = 280 \nbendRadius = 40 \ntireTreadWidth = 10 \ntireTreadDepth = 10 \ntireTreadOffset = 80 \n\n// Create the sketch of the tire\ntireSketch = startSketchOn(\"XY\")\n  |> startProfileAt([tireInnerDiameter / 2, tireDepth / 2], %)\n  |> lineTo([tireOuterDiameter / 2 - bendRadius, tireDepth / 2], %, $edge1)\n  |> tangentialArc({\n    offset: -90,\n    radius: bendRadius,\n  }, %)\n  |> lineTo([tireOuterDiameter / 2, tireDepth/2 - tireTreadOffset], %)\n  |> line([-tireTreadDepth, 0], %)\n  |> line([0, -tireTreadWidth], %)\n  |> line([tireTreadDepth, 0], %)\n  |> lineTo([tireOuterDiameter / 2, -tireDepth/2 + tireTreadOffset + tireTreadWidth], %)\n  |> line([-tireTreadDepth, 0], %)\n  |> line([0, -tireTreadWidth], %)\n  |> line([tireTreadDepth, 0], %)\n  |> lineTo([tireOuterDiameter / 2, -tireDepth / 2 + bendRadius], %)\n  |> tangentialArc({\n    offset: -90,\n    radius: bendRadius,\n  }, %)\n  |> lineTo([tireInnerDiameter / 2, -tireDepth / 2], %, $edge2)\n  |> close(%)\n\n// Revolve the sketch to create the tire\ntire = revolve({ axis: \"Y\" }, tireSketch)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'washer' file, and how does it achieve the creation of a washer component?"}, {"role": "assistant", "content": "// Washer\n// A small, typically disk-shaped component with a hole in the middle, used in a wide range of applications, primarily in conjunction with fasteners like bolts and screws. Washers distribute the load of a fastener across a broader area. This is especially important when the fastening surface is soft or uneven, as it helps to prevent damage to the surface and ensures the load is evenly distributed, reducing the risk of the fastener becoming loose over time.\n\n\n// Define constants in inches (in)\ninnerDiameter = 0.203\nouterDiameter = 0.438\nthicknessMax = 0.038\nthicknessMin = 0.024\n\n\n// Write a function that defines the washer and extrude it.\nfn washer = (plane, innerDia, outerDia, thk) => {\n  // Define the sketch of the washer\n  washerSketch = startSketchOn(plane)\n    |> circle({ center: [0, 0], radius: outerDia / 2 }, %)\n    |> hole(circle({ center: [0, 0], radius: innerDia / 2 }, %), %)\n\n  washer = extrude(thk, washerSketch)\n  return washer\n}\n\nwasher('XY', innerDiameter, outerDiameter, thicknessMax)"}]}
{"system": "The following QA pair is based on KCL (KittyCAD Language) documentation, demonstrating the usage and functionality of KCL functions for generating specific CAD designs.", "messages": [{"role": "user", "content": "What is the purpose of the KCL code in the 'wheel-rotor' file, and how does it achieve the creation of a disc brake rotor component?"}, {"role": "assistant", "content": "// Wheel rotor\n// A component of a disc brake system. It provides a surface for brake pads to press against, generating the friction needed to slow or stop the vehicle.\n\n\n// Define constants\n// Base units for this model are in inches\nrotorDiameter = 12\nrotorInnerDiameter = 6\nrotorSinglePlateThickness = 0.25\nrotorInnerDiameterThickness = 0.5\nlugHolePatternDia = 3\nlugSpacing = 114.3 * mm()\nrotorTotalThickness = 1\nspacerPatternDiameter = 11\nspacerDiameter = 0.25\nspacerLength = rotorTotalThickness - (2 * rotorSinglePlateThickness)\nspacerCount = 16\nwheelDiameter = 19\nlugCount = 5\nyAxisOffset = 0.5\ndrillAndSlotCount = 5\n\nrotorPlane = {\n  plane: {\n    origin: { x: 0, y: yAxisOffset, z: 0 },\n    xAxis: { x: -1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 0, y: 1, z: 0 }\n  }\n}\n\nfn lugPattern = (plane) => {\n  lugHolePattern = circle({\n         center: [-lugSpacing / 2, 0],\n         radius: 0.315\n       }, plane)\n    |> patternCircular2d({\n         arcDegrees: 360,\n         center: [0, 0],\n         instances: lugCount,\n         rotateDuplicates: true\n       }, %)\n  return lugHolePattern\n}\n\nrotorSketch = startSketchOn(rotorPlane)\n  |> circle({\n       center: [0, 0],\n       radius: rotorDiameter / 2\n     }, %)\n  |> hole(lugPattern(%), %)\nrotor = extrude(rotorSinglePlateThickness, rotorSketch)\n\nrotorBumpSketch = startSketchOn(rotorPlane)\n  |> circle({\n       center: [0, 0],\n       radius: rotorInnerDiameter / 2\n     }, %)\n  |> hole(lugPattern(%), %)\nrotorBump = extrude(-rotorInnerDiameterThickness, rotorBumpSketch)\n\nrotorSecondaryPlatePlane = {\n  plane: {\n    origin: {\n      x: 0,\n      y: yAxisOffset + rotorTotalThickness * 0.75,\n      z: 0\n    },\n    xAxis: { x: -1, y: 0, z: 0 },\n    yAxis: { x: 0, y: 0, z: 1 },\n    zAxis: { x: 0, y: 1, z: 0 }\n  }\n}\n\nsecondaryRotorSketch = startSketchOn(rotorSecondaryPlatePlane)\n  |> circle({\n       center: [0, 0],\n       radius: rotorDiameter / 2\n     }, %)\n  |> hole(lugPattern(%), %)\n\nsecondRotor = extrude(rotorSinglePlateThickness, secondaryRotorSketch)\n\nspacerSketch = startSketchOn(rotorSecondaryPlatePlane)\n  |> circle({\n       center: [spacerPatternDiameter / 2, 0],\n       radius: spacerDiameter\n     }, %)\n  |> patternCircular2d({\n       arcDegrees: 360,\n       center: [0, 0],\n       instances: spacerCount,\n       rotateDuplicates: true\n     }, %)\n\nspacers = extrude(-spacerLength, spacerSketch)\n\nrotorSlottedSketch = startSketchOn(rotor, 'START')\n  |> startProfileAt([2.17, 2.56], %)\n  |> xLine(0.12, %)\n  |> yLine(2.56, %)\n  |> xLine(-0.12, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> patternCircular2d({\n       center: [0, 0],\n       instances: drillAndSlotCount,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nrotorSlotted = extrude(-rotorSinglePlateThickness / 2, rotorSlottedSketch)\n\nrotorDrilledSketch = startSketchOn(rotor, 'START')\n  |> circle({ center: [1.34, 3.23], radius: 0.12 }, %)\n  |> patternLinear2d({\n       axis: [-0.02, 0.04],\n       instances: 3,\n       distance: 1.1\n     }, %)\n  |> patternCircular2d({\n       center: [0, 0],\n       instances: drillAndSlotCount,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nrotorDrilled = extrude(-rotorSinglePlateThickness, rotorDrilledSketch)\n\nsecondRotorSlottedSketch = startSketchOn(secondRotor, 'END')\n  |> startProfileAt([-2.17, 2.56], %)\n  |> xLine(-0.12, %)\n  |> yLine(2.56, %)\n  |> xLine(0.12, %)\n  |> lineTo([profileStartX(%), profileStartY(%)], %)\n  |> close(%)\n  |> patternCircular2d({\n       center: [0, 0],\n       instances: drillAndSlotCount,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nsecondRotorSlotted = extrude(-rotorSinglePlateThickness / 2, secondRotorSlottedSketch)\n\nsecondRotorDrilledSketch = startSketchOn(secondRotor, 'START')\n  |> circle({ center: [1.34, 3.23], radius: 0.12 }, %)\n  |> patternLinear2d({\n       axis: [-0.02, 0.04],\n       instances: 3,\n       distance: 1.1\n     }, %)\n  |> patternCircular2d({\n       center: [0, 0],\n       instances: drillAndSlotCount,\n       arcDegrees: 360,\n       rotateDuplicates: true\n     }, %)\n\nsecondRotorDrilled = extrude(-rotorSinglePlateThickness, secondRotorDrilledSketch)"}]}
